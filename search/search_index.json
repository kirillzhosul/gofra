{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gofra A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute Overview Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ). Quick start Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main FD_STD_OUT \"Hello, World!\\n\" sc_write drop end Features Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries (including libc) Platform support Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin) Prerequirements Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Installation For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help (Step 3): Try an example (Optional) # More examples available in `./examples` gofra examples/01_hello_world.gof","title":"About"},{"location":"#gofra","text":"A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute","title":"Gofra"},{"location":"#overview","text":"Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ).","title":"Overview"},{"location":"#quick-start","text":"Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main FD_STD_OUT \"Hello, World!\\n\" sc_write drop end","title":"Quick start"},{"location":"#features","text":"Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries (including libc)","title":"Features"},{"location":"#platform-support","text":"Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin)","title":"Platform support"},{"location":"#prerequirements","text":"Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler","title":"Prerequirements"},{"location":"#installation","text":"For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help (Step 3): Try an example (Optional) # More examples available in `./examples` gofra examples/01_hello_world.gof","title":"Installation"},{"location":"ffi/","text":"FFI (Foreign Function Interface) Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI. extern marker Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[ptr] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error Type contracts for FFI To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you Variadic arguments (type contracts) For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments) Linker stage For letting linker know about that dependencies (Libraries with FFI), you can pass -L flag(s) to the compiler For example linking with raylib and using their functions: -L=-lraylib -L=-L/opt/homebrew/lib","title":"FFI (Foreign Function Interface)"},{"location":"ffi/#ffi-foreign-function-interface","text":"Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI.","title":"FFI (Foreign Function Interface)"},{"location":"ffi/#extern-marker","text":"Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[ptr] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error","title":"extern marker"},{"location":"ffi/#type-contracts-for-ffi","text":"To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you","title":"Type contracts for FFI"},{"location":"ffi/#variadic-arguments-type-contracts","text":"For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments)","title":"Variadic arguments (type contracts)"},{"location":"ffi/#linker-stage","text":"For letting linker know about that dependencies (Libraries with FFI), you can pass -L flag(s) to the compiler For example linking with raylib and using their functions: -L=-lraylib -L=-L/opt/homebrew/lib","title":"Linker stage"},{"location":"installation/","text":"Installation Prerequirements Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install: Install (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help (Step 3): Try an example (Optional) # More examples available in `./examples` gofra examples/01_hello_world.gof Development installation (Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequirements","text":"Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install:","title":"Prerequirements"},{"location":"installation/#install","text":"(Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help (Step 3): Try an example (Optional) # More examples available in `./examples` gofra examples/01_hello_world.gof","title":"Install"},{"location":"installation/#development-installation","text":"(Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Development installation"},{"location":"overview/","text":"Language overview As language is stack based so your basic action is to put something on a stack , like 2 2 will push 2 and then another 2 on stack so stack underneath will look like [2, 2] If you want to operate on that numbers you may do something like 3 2 + which is same as 3 + 2 in other language or default math. Underneath this will mean: push 3 on stack -> push 2 on stack -> take 2 elements from stack -> sum them -> push result back. Stack after that will become [5] Conditionals is also a bit controversial: 1 2 == if ... end which is same as other languages: if (1 == 2){ ... } (You can follow previous math example for checking stack manipulation) For writing a bit more complex programs you may want to use macros and includes: Macros is an collection of tokens (like functions in other languages) but does not have an object-like system they just an way to not write same logic (for now) So, this code: macro multiply_by_2 2 * end 4 multiply_by_2 at compilation stage will be converted into simple 4 2 * (tokens expanded) For importing some file (same as macros system but for files) you can use import \"file.gof\" Examples Examples may be found inside ./examples directory Milestones and planned features Standard library with not only syscall mapping Stability improvements Support for x86_64 Windows More examples","title":"Overview"},{"location":"overview/#language-overview","text":"As language is stack based so your basic action is to put something on a stack , like 2 2 will push 2 and then another 2 on stack so stack underneath will look like [2, 2] If you want to operate on that numbers you may do something like 3 2 + which is same as 3 + 2 in other language or default math. Underneath this will mean: push 3 on stack -> push 2 on stack -> take 2 elements from stack -> sum them -> push result back. Stack after that will become [5] Conditionals is also a bit controversial: 1 2 == if ... end which is same as other languages: if (1 == 2){ ... } (You can follow previous math example for checking stack manipulation) For writing a bit more complex programs you may want to use macros and includes: Macros is an collection of tokens (like functions in other languages) but does not have an object-like system they just an way to not write same logic (for now) So, this code: macro multiply_by_2 2 * end 4 multiply_by_2 at compilation stage will be converted into simple 4 2 * (tokens expanded) For importing some file (same as macros system but for files) you can use import \"file.gof\"","title":"Language overview"},{"location":"overview/#examples","text":"Examples may be found inside ./examples directory","title":"Examples"},{"location":"overview/#milestones-and-planned-features","text":"Standard library with not only syscall mapping Stability improvements Support for x86_64 Windows More examples","title":"Milestones and planned features"}]}