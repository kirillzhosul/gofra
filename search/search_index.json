{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gofra A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute Overview Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ). Quick start Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main \"Hello, World!\\n\" print end Features Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries (including libc) Platform support Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin) Prerequirements Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Installation For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"About"},{"location":"#gofra","text":"A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute","title":"Gofra"},{"location":"#overview","text":"Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ).","title":"Overview"},{"location":"#quick-start","text":"Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main \"Hello, World!\\n\" print end","title":"Quick start"},{"location":"#features","text":"Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries (including libc)","title":"Features"},{"location":"#platform-support","text":"Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin)","title":"Platform support"},{"location":"#prerequirements","text":"Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler","title":"Prerequirements"},{"location":"#installation","text":"For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Installation"},{"location":"installation/","text":"Installation Prerequirements Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install: Install (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help Development installation (Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequirements","text":"Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install:","title":"Prerequirements"},{"location":"installation/#install","text":"(Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Install"},{"location":"installation/#development-installation","text":"(Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Development installation"},{"location":"advanced/","text":"Advanced usage and tutorials Preprocessor FFI Optimizations","title":"Advanced"},{"location":"advanced/#advanced-usage-and-tutorials","text":"","title":"Advanced usage and tutorials"},{"location":"advanced/#preprocessor","text":"","title":"Preprocessor"},{"location":"advanced/#ffi","text":"","title":"FFI"},{"location":"advanced/#optimizations","text":"","title":"Optimizations"},{"location":"advanced/ffi/","text":"FFI (Foreign Function Interface) Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI. extern marker Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[ptr] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error Type contracts for FFI To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you Variadic arguments (type contracts) For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments) Linker stage For letting linker know about that dependencies (Libraries with FFI), you can pass -L flag(s) to the compiler For example linking with raylib and using their functions: -L=-lraylib -L=-L/opt/homebrew/lib Additional flags: @ By using @ flag you may specify for example against which function to link your external: extern func int _puts[ptr]@link[_puts] In that case is straighforward same name, but you can change that, and","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#ffi-foreign-function-interface","text":"Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI.","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#extern-marker","text":"Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[ptr] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error","title":"extern marker"},{"location":"advanced/ffi/#type-contracts-for-ffi","text":"To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you","title":"Type contracts for FFI"},{"location":"advanced/ffi/#variadic-arguments-type-contracts","text":"For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments)","title":"Variadic arguments (type contracts)"},{"location":"advanced/ffi/#linker-stage","text":"For letting linker know about that dependencies (Libraries with FFI), you can pass -L flag(s) to the compiler For example linking with raylib and using their functions: -L=-lraylib -L=-L/opt/homebrew/lib","title":"Linker stage"},{"location":"advanced/ffi/#additional-flags","text":"By using @ flag you may specify for example against which function to link your external: extern func int _puts[ptr]@link[_puts] In that case is straighforward same name, but you can change that, and","title":"Additional flags: @"},{"location":"advanced/optimizations/","text":"Optimizer and optimizations Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now) Optimizer level features Optimization Minimum level DCE 1 Function inlining 1 Optimization features (passes) Here is an list of all possible optimizations that optimizer may apply DCE (Dead-Code-Elimination) Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searchs for functions that is not being called atleast once and removes them from final IR so them does not appear in final binary as being unused. Does not removes global functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std.gof\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function. Function inlining Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recusrive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase finaly binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-and-optimizations","text":"Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now)","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-level-features","text":"Optimization Minimum level DCE 1 Function inlining 1","title":"Optimizer level features"},{"location":"advanced/optimizations/#optimization-features-passes","text":"Here is an list of all possible optimizations that optimizer may apply","title":"Optimization features (passes)"},{"location":"advanced/optimizations/#dce-dead-code-elimination","text":"Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searchs for functions that is not being called atleast once and removes them from final IR so them does not appear in final binary as being unused. Does not removes global functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std.gof\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function.","title":"DCE (Dead-Code-Elimination)"},{"location":"advanced/optimizations/#function-inlining","text":"Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recusrive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase finaly binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Function inlining"},{"location":"advanced/preprocessor/","text":"Preprocessor Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occured at next possible stage: parser) All preprocessor keywords begins with # Include system and #include Most of the time you dont write program in a single file, or require additional code from libraries, in Gofra #inlcude allows to straighforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Inlcude system is like recursive so all definitions of an preprocessor will be available at include side Module include In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries Searching strategy At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories","title":"Preprocessor"},{"location":"advanced/preprocessor/#preprocessor","text":"Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occured at next possible stage: parser) All preprocessor keywords begins with #","title":"Preprocessor"},{"location":"advanced/preprocessor/#include-system-and-include","text":"Most of the time you dont write program in a single file, or require additional code from libraries, in Gofra #inlcude allows to straighforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Inlcude system is like recursive so all definitions of an preprocessor will be available at include side","title":"Include system and #include"},{"location":"advanced/preprocessor/#module-include","text":"In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries","title":"Module include"},{"location":"advanced/preprocessor/#searching-strategy","text":"At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories","title":"Searching strategy"},{"location":"tutorial/","text":"Usage and tutorials Stack management intrinsics Control flow Variables Memory management Editor support","title":"Tutorial"},{"location":"tutorial/#usage-and-tutorials","text":"","title":"Usage and tutorials"},{"location":"tutorial/#stack-management-intrinsics","text":"","title":"Stack management intrinsics"},{"location":"tutorial/#control-flow","text":"","title":"Control flow"},{"location":"tutorial/#variables","text":"","title":"Variables"},{"location":"tutorial/#memory-management","text":"","title":"Memory management"},{"location":"tutorial/#editor-support","text":"","title":"Editor support"},{"location":"tutorial/control-flow/","text":"Control flow constructions If if is an control flow block construction that consumes single boolean type argument and if it is not equals to 0 - jumps into block body, otherwise jumps to own closure end block 0 1 == if // will not happen end 1 1 == if // will fall here end While-do while is an control flow block construction that consumes single boolean type argument and if it is not equals to 0 - jumps into block body, otherwise jumps to own closure end block, but in difference with if, will always jump back to while after reaching own end , so only way to left that loop is out of that condition var counter int counter 0 !< while counter < 10 do // Will print 10 times \"Hello!\" print counter copy ?> inc !< end In control-flow reference graph: while -> end do -> while end -> while Additional notes on logic operators Language supports logical AND ( && ) and OR ( || ), read more at operator / intrinsics page.","title":"Control flow constructions"},{"location":"tutorial/control-flow/#control-flow-constructions","text":"","title":"Control flow constructions"},{"location":"tutorial/control-flow/#if","text":"if is an control flow block construction that consumes single boolean type argument and if it is not equals to 0 - jumps into block body, otherwise jumps to own closure end block 0 1 == if // will not happen end 1 1 == if // will fall here end","title":"If"},{"location":"tutorial/control-flow/#while-do","text":"while is an control flow block construction that consumes single boolean type argument and if it is not equals to 0 - jumps into block body, otherwise jumps to own closure end block, but in difference with if, will always jump back to while after reaching own end , so only way to left that loop is out of that condition var counter int counter 0 !< while counter < 10 do // Will print 10 times \"Hello!\" print counter copy ?> inc !< end In control-flow reference graph: while -> end do -> while end -> while","title":"While-do"},{"location":"tutorial/control-flow/#additional-notes-on-logic-operators","text":"Language supports logical AND ( && ) and OR ( || ), read more at operator / intrinsics page.","title":"Additional notes on logic operators"},{"location":"tutorial/editor-support/","text":"IDE (Editor) support VIM (GitHub) Visual Studio Code Source of an editor extension is located in Gofra source code in editors directory, you can bundle that and use (This page should be documented later)","title":"IDE (Editor) support"},{"location":"tutorial/editor-support/#ide-editor-support","text":"","title":"IDE (Editor) support"},{"location":"tutorial/editor-support/#vim-github","text":"","title":"VIM (GitHub)"},{"location":"tutorial/editor-support/#visual-studio-code","text":"Source of an editor extension is located in Gofra source code in editors directory, you can bundle that and use (This page should be documented later)","title":"Visual Studio Code"},{"location":"tutorial/memory-management/","text":"Memory management Most goal of an program is to manage an memory, in Gofra of course you have ways to manage bytes Size (width) of that load / store instructions is different by CPU architecture pointer-width and word-size Store into memory Mnemonics: a b -> _ _ Intrinsic: !< Consumes two arguments from stack [address, value] and stores that value at given address Example var somevar int somevar 1 !< // store 1 into somevar Load from memory Mnemonics: a -> b Intrinsic: ?> Consumes one argument from stack [address] and loads value at given address Example var somevar int somevar 1 !< // store 1 into somevar somevar ?> // load 1 into stack from somevar","title":"Memory management"},{"location":"tutorial/memory-management/#memory-management","text":"Most goal of an program is to manage an memory, in Gofra of course you have ways to manage bytes Size (width) of that load / store instructions is different by CPU architecture pointer-width and word-size","title":"Memory management"},{"location":"tutorial/memory-management/#store-into-memory","text":"Mnemonics: a b -> _ _ Intrinsic: !< Consumes two arguments from stack [address, value] and stores that value at given address Example var somevar int somevar 1 !< // store 1 into somevar","title":"Store into memory"},{"location":"tutorial/memory-management/#load-from-memory","text":"Mnemonics: a -> b Intrinsic: ?> Consumes one argument from stack [address] and loads value at given address Example var somevar int somevar 1 !< // store 1 into somevar somevar ?> // load 1 into stack from somevar","title":"Load from memory"},{"location":"tutorial/stack-management-intrinsics/","text":"Stack management intrinsics For managing an stack you must have some less-or-more complex commands for example like swap or rot , langauge supports some of them SWAP Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 2 3 swap - // -1 DROP Mnemonics: a -> _ Drops element from stack Example: 2 2 2 drop + // 4, and empty stack","title":"Stack management intrinsics"},{"location":"tutorial/stack-management-intrinsics/#stack-management-intrinsics","text":"For managing an stack you must have some less-or-more complex commands for example like swap or rot , langauge supports some of them","title":"Stack management intrinsics"},{"location":"tutorial/stack-management-intrinsics/#swap","text":"Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 2 3 swap - // -1","title":"SWAP"},{"location":"tutorial/stack-management-intrinsics/#drop","text":"Mnemonics: a -> _ Drops element from stack Example: 2 2 2 drop + // 4, and empty stack","title":"DROP"},{"location":"tutorial/variables/","text":"Variables That page is being writed, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions) Variable definitions Variable definitions looks like that: // Primitive type var {name} {type} // Composite type var array {type}[{size_in_elements}] It must start with var then name and type Primitive and composite types: differences Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of characater (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type Local and static (global) variable location: differences Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reseted // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout Local variables: alignment on CPUs Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Variables"},{"location":"tutorial/variables/#variables","text":"That page is being writed, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions)","title":"Variables"},{"location":"tutorial/variables/#variable-definitions","text":"Variable definitions looks like that: // Primitive type var {name} {type} // Composite type var array {type}[{size_in_elements}] It must start with var then name and type","title":"Variable definitions"},{"location":"tutorial/variables/#primitive-and-composite-types-differences","text":"Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of characater (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type","title":"Primitive and composite types: differences"},{"location":"tutorial/variables/#local-and-static-global-variable-location-differences","text":"Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reseted // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout","title":"Local and static (global) variable location: differences"},{"location":"tutorial/variables/#local-variables-alignment-on-cpus","text":"Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Local variables: alignment on CPUs"}]}