{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gofra A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute Overview Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ). Quick start Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main \"Hello, World!\\n\" print end Features Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries Platform support Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin) Prerequirements Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Installation For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"About"},{"location":"#gofra","text":"A Stack-based compiled programming language Project is made for FUN and educational purposes! Don`t expect anything cool from it and just try/contribute","title":"Gofra"},{"location":"#overview","text":"Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ).","title":"Overview"},{"location":"#quick-start","text":"Here's a simple \"Hello, World!\" example: include \"std.gof\" func void main \"Hello, World!\\n\" print end","title":"Quick start"},{"location":"#features","text":"Low-level - Write unsafe, low-level code with direct memory access Native Compilation - Generates optimized native assembly code Type Safety - Validates stack usage and type correctness at compile time C FFI - Seamless integration with C libraries","title":"Features"},{"location":"#platform-support","text":"Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target: x86_64 (Linux) AArch64 macOS (Darwin)","title":"Platform support"},{"location":"#prerequirements","text":"Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler","title":"Prerequirements"},{"location":"#installation","text":"For full installation steps, please visit Installation page Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Installation"},{"location":"editors/","text":"IDE and Editor support Enhance your Gofra development experience with official and unofficial extensions for your favorite code editor. These extensions provide syntax highlighting, code snippets, and useful commands to streamline your workflow. Vim / Neovim The Gofra plugin for Vim is available on GitHub and can be easily installed. Huge thanks to Stepan Zubkov for developing an extension! Installation Please refer to their respective documentation using the repository URL: github.com/stepanzubkov/gofra.vim Features Syntax Highlighting: Support for .gof file syntax. Visual Studio Code The extension is currently available by installing it directly from the source. We are working on publishing it to the Visual Studio Code Marketplace for easier installation. Manual Installation from Source 1.Clone the Repository: git clone https://github.com/kirillzhosul/gofra cd gofra/editors/vscode Package the Extension: You need to have Node.js and the vsce (Visual Studio Code Extensions) tool installed. npm install -g @vscode/vsce vsce package This command will create a .vsix file in the directory. Install in VS Code: Open VS Code. Go to the Extensions view (Ctrl+Shift+X / Cmd+Shift+X). Click the \"...\" menu in the top-right of the Extensions panel and select Install from VSIX.... Navigate to and select the .vsix file you created in the previous step. Reload VS Code when prompted. Features Syntax Highlighting: Support for .gof file syntax. Other Editors & Contributing Support for your editor not listed here? We welcome contributions! The source code for all editor extensions is located in the editors directory of the main Gofra repository or your own repository if you wish to separate that. If you'd like to create an extension for another editor (such as Sublime Text, IntelliJ IDEA, or Emacs), please use the existing implementations as a reference. Check the editors directory in the Gofra source code . Feel free to open an issue on GitHub to discuss your plans for a new extension. Submit a pull request with your new extension, and we'll be happy to include it here!","title":"IDE and Editor support"},{"location":"editors/#ide-and-editor-support","text":"Enhance your Gofra development experience with official and unofficial extensions for your favorite code editor. These extensions provide syntax highlighting, code snippets, and useful commands to streamline your workflow.","title":"IDE and Editor support"},{"location":"editors/#vim-neovim","text":"The Gofra plugin for Vim is available on GitHub and can be easily installed. Huge thanks to Stepan Zubkov for developing an extension!","title":"Vim / Neovim"},{"location":"editors/#installation","text":"Please refer to their respective documentation using the repository URL: github.com/stepanzubkov/gofra.vim","title":"Installation"},{"location":"editors/#features","text":"Syntax Highlighting: Support for .gof file syntax.","title":"Features"},{"location":"editors/#visual-studio-code","text":"The extension is currently available by installing it directly from the source. We are working on publishing it to the Visual Studio Code Marketplace for easier installation.","title":"Visual Studio Code"},{"location":"editors/#manual-installation-from-source","text":"1.Clone the Repository: git clone https://github.com/kirillzhosul/gofra cd gofra/editors/vscode Package the Extension: You need to have Node.js and the vsce (Visual Studio Code Extensions) tool installed. npm install -g @vscode/vsce vsce package This command will create a .vsix file in the directory. Install in VS Code: Open VS Code. Go to the Extensions view (Ctrl+Shift+X / Cmd+Shift+X). Click the \"...\" menu in the top-right of the Extensions panel and select Install from VSIX.... Navigate to and select the .vsix file you created in the previous step. Reload VS Code when prompted.","title":"Manual Installation from Source"},{"location":"editors/#features_1","text":"Syntax Highlighting: Support for .gof file syntax.","title":"Features"},{"location":"editors/#other-editors-contributing","text":"Support for your editor not listed here? We welcome contributions! The source code for all editor extensions is located in the editors directory of the main Gofra repository or your own repository if you wish to separate that. If you'd like to create an extension for another editor (such as Sublime Text, IntelliJ IDEA, or Emacs), please use the existing implementations as a reference. Check the editors directory in the Gofra source code . Feel free to open an issue on GitHub to discuss your plans for a new extension. Submit a pull request with your new extension, and we'll be happy to include it here!","title":"Other Editors &amp; Contributing"},{"location":"installation/","text":"Installation Prerequirements Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install: Install (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help Development installation (Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequirements","text":"Gofra is an Python-based toolchain so you must only required to have Python installation. But as toolchain compiled code, it depends on target-specific linker and assembler. Python >3.12.x available as python or python3 command GNU/Mach-O Linker (ld) - For linking compiled objects Assembler (as) - Typically included with Clang LLVM compiler Gofra is distributed as single Python-based toolchain. To install:","title":"Prerequirements"},{"location":"installation/#install","text":"(Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Install"},{"location":"installation/#development-installation","text":"(Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify Installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate local gofra command over system-wide gofra if you inside environment (e.g poetry shell ))","title":"Development installation"},{"location":"sitemap/","text":"Map of the site Preprocessor FFI Optimizations Type checker Linker IDE and Editor support Control flow Memory management Stack management intrinsics Variables Structures Type casts Installation Editors","title":"Map of the site"},{"location":"sitemap/#map-of-the-site","text":"","title":"Map of the site"},{"location":"sitemap/#preprocessor","text":"","title":"Preprocessor"},{"location":"sitemap/#ffi","text":"","title":"FFI"},{"location":"sitemap/#optimizations","text":"","title":"Optimizations"},{"location":"sitemap/#type-checker","text":"","title":"Type checker"},{"location":"sitemap/#linker","text":"","title":"Linker"},{"location":"sitemap/#ide-and-editor-support","text":"","title":"IDE and Editor support"},{"location":"sitemap/#control-flow","text":"","title":"Control flow"},{"location":"sitemap/#memory-management","text":"","title":"Memory management"},{"location":"sitemap/#stack-management-intrinsics","text":"","title":"Stack management intrinsics"},{"location":"sitemap/#variables","text":"","title":"Variables"},{"location":"sitemap/#structures","text":"","title":"Structures"},{"location":"sitemap/#type-casts","text":"","title":"Type casts"},{"location":"sitemap/#installation","text":"","title":"Installation"},{"location":"sitemap/#editors","text":"","title":"Editors"},{"location":"advanced/","text":"Advanced usage and tutorials Preprocessor FFI Optimizations Type checker","title":"Advanced"},{"location":"advanced/#advanced-usage-and-tutorials","text":"","title":"Advanced usage and tutorials"},{"location":"advanced/#preprocessor","text":"","title":"Preprocessor"},{"location":"advanced/#ffi","text":"","title":"FFI"},{"location":"advanced/#optimizations","text":"","title":"Optimizations"},{"location":"advanced/#type-checker","text":"","title":"Type checker"},{"location":"advanced/ffi/","text":"FFI (Foreign Function Interface) Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI. extern marker Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[*char[]] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error Type contracts for FFI To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you Variadic arguments (type contracts) For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments) Linker stage For letting linker know about that dependencies (Libraries with FFI), you can pass -l flag(s) to the compiler For example linking with raylib and using their functions: -lraylib ( -L/opt/homebrew/lib if search directory was not found with pkgconfig ( --no-pkg-config ))","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#ffi-foreign-function-interface","text":"Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI.","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#extern-marker","text":"Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[*char[]] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error","title":"extern marker"},{"location":"advanced/ffi/#type-contracts-for-ffi","text":"To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you","title":"Type contracts for FFI"},{"location":"advanced/ffi/#variadic-arguments-type-contracts","text":"For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments)","title":"Variadic arguments (type contracts)"},{"location":"advanced/ffi/#linker-stage","text":"For letting linker know about that dependencies (Libraries with FFI), you can pass -l flag(s) to the compiler For example linking with raylib and using their functions: -lraylib ( -L/opt/homebrew/lib if search directory was not found with pkgconfig ( --no-pkg-config ))","title":"Linker stage"},{"location":"advanced/optimizations/","text":"Optimizer and optimizations Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now) Optimizer level features Optimization Minimum level DCE 1 Function inlining 1 Optimization features (passes) Here is an list of all possible optimizations that optimizer may apply DCE (Dead-Code-Elimination) Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searches for functions that is not being called at least once and removes them from final IR so them does not appear in final binary as being unused. Does not removes global functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std.gof\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function. Function inlining Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recursive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase final binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-and-optimizations","text":"Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now)","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-level-features","text":"Optimization Minimum level DCE 1 Function inlining 1","title":"Optimizer level features"},{"location":"advanced/optimizations/#optimization-features-passes","text":"Here is an list of all possible optimizations that optimizer may apply","title":"Optimization features (passes)"},{"location":"advanced/optimizations/#dce-dead-code-elimination","text":"Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searches for functions that is not being called at least once and removes them from final IR so them does not appear in final binary as being unused. Does not removes global functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std.gof\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function.","title":"DCE (Dead-Code-Elimination)"},{"location":"advanced/optimizations/#function-inlining","text":"Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recursive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase final binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Function inlining"},{"location":"advanced/preprocessor/","text":"Preprocessor Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occurred at next possible stage: parser) All preprocessor keywords begins with # Include system and #include Most of the time you do not write program in a single file, or require additional code from libraries, in Gofra #include allows to straightforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Include system is like recursive so all definitions of an preprocessor will be available at include side Module include In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries Searching strategy At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories","title":"Preprocessor"},{"location":"advanced/preprocessor/#preprocessor","text":"Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occurred at next possible stage: parser) All preprocessor keywords begins with #","title":"Preprocessor"},{"location":"advanced/preprocessor/#include-system-and-include","text":"Most of the time you do not write program in a single file, or require additional code from libraries, in Gofra #include allows to straightforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Include system is like recursive so all definitions of an preprocessor will be available at include side","title":"Include system and #include"},{"location":"advanced/preprocessor/#module-include","text":"In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries","title":"Module include"},{"location":"advanced/preprocessor/#searching-strategy","text":"At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories","title":"Searching strategy"},{"location":"advanced/typechecker/","text":"Type checker Type checking is always performed by default at compile-time (unless -nt or --no-typecheck flag is passed) It validates all stack usages and function calls Implementation Type checker is implemented as type-stack machine which behaves like stack based machine but operates on types So for example 2 will resolve into typestack = [INT] Typechecker will perform type safety validation even for unused functions (expect function calls, as there is no calls for unused functions) Unless you apply DCE optimization at compile-time (as it performed before type checker stage) Type checker will go into each function and validate its return type and stack usage and emit an error if something weird is found When typechecker found an call inside current function, it will consume desired parameters as arguments from type stack and push return type unless it not void type Type comparison Typechecker always uses strategy called strict-same-type which means types must be always same and no inference / type lowering is possible (you must always statically type cast for fixing errors) Possible next update will introduce something new, allowing to use implicit-byte-size strategy or any type lowering automatically at typechecker stage Is type checker affects runtime / generate code? Type checker is meant to only type-safety feature, so no generated code is affected by typechecker, even type casts are static ones and only applied to type checker, not anything else","title":"Type checker"},{"location":"advanced/typechecker/#type-checker","text":"Type checking is always performed by default at compile-time (unless -nt or --no-typecheck flag is passed) It validates all stack usages and function calls","title":"Type checker"},{"location":"advanced/typechecker/#implementation","text":"Type checker is implemented as type-stack machine which behaves like stack based machine but operates on types So for example 2 will resolve into typestack = [INT] Typechecker will perform type safety validation even for unused functions (expect function calls, as there is no calls for unused functions) Unless you apply DCE optimization at compile-time (as it performed before type checker stage) Type checker will go into each function and validate its return type and stack usage and emit an error if something weird is found When typechecker found an call inside current function, it will consume desired parameters as arguments from type stack and push return type unless it not void type","title":"Implementation"},{"location":"advanced/typechecker/#type-comparison","text":"Typechecker always uses strategy called strict-same-type which means types must be always same and no inference / type lowering is possible (you must always statically type cast for fixing errors) Possible next update will introduce something new, allowing to use implicit-byte-size strategy or any type lowering automatically at typechecker stage","title":"Type comparison"},{"location":"advanced/typechecker/#is-type-checker-affects-runtime-generate-code","text":"Type checker is meant to only type-safety feature, so no generated code is affected by typechecker, even type casts are static ones and only applied to type checker, not anything else","title":"Is type checker affects runtime / generate code?"},{"location":"linker/","text":"Gofra Linker (gofra-ld) Gofra Linker is a cross-platform tool that links multiple object files and libraries to produce output in various formats including executables, shared libraries, and static objects. It serves as a unified interface to underlying system linkers while providing consistent behavior across different platforms. Installation Gofra Linker is distributed as part of the Gofra toolchain and is available system-wide as gofra-ld after installation. Linker backends Gofra Linker is uses what is called backend under the hood - after selecting appropriate backend it composes proper linker command and executes it. At current moment there is only 2 backends: gnu-ld and apple-ld (shares almost same philosophy and interface) By default backend is inferred by host machine and target but can be overridden by passing --linker-backend argument to the CLI.","title":"Gofra Linker (gofra-ld)"},{"location":"linker/#gofra-linker-gofra-ld","text":"Gofra Linker is a cross-platform tool that links multiple object files and libraries to produce output in various formats including executables, shared libraries, and static objects. It serves as a unified interface to underlying system linkers while providing consistent behavior across different platforms.","title":"Gofra Linker (gofra-ld)"},{"location":"linker/#installation","text":"Gofra Linker is distributed as part of the Gofra toolchain and is available system-wide as gofra-ld after installation.","title":"Installation"},{"location":"linker/#linker-backends","text":"Gofra Linker is uses what is called backend under the hood - after selecting appropriate backend it composes proper linker command and executes it. At current moment there is only 2 backends: gnu-ld and apple-ld (shares almost same philosophy and interface) By default backend is inferred by host machine and target but can be overridden by passing --linker-backend argument to the CLI.","title":"Linker backends"},{"location":"tutorial/","text":"Usage and tutorials IDE and Editor support Control flow Memory management Stack management intrinsics Variables Structures Type casts","title":"Tutorial"},{"location":"tutorial/#usage-and-tutorials","text":"","title":"Usage and tutorials"},{"location":"tutorial/#ide-and-editor-support","text":"","title":"IDE and Editor support"},{"location":"tutorial/#control-flow","text":"","title":"Control flow"},{"location":"tutorial/#memory-management","text":"","title":"Memory management"},{"location":"tutorial/#stack-management-intrinsics","text":"","title":"Stack management intrinsics"},{"location":"tutorial/#variables","text":"","title":"Variables"},{"location":"tutorial/#structures","text":"","title":"Structures"},{"location":"tutorial/#type-casts","text":"","title":"Type casts"},{"location":"tutorial/control-flow/","text":"Control Flow Constructs Gofra provides essential control flow constructs for conditional execution and looping. if Statement The if statement evaluates a boolean condition and executes the block if the condition is non-zero. Syntax <condition> if // code to execute if condition is true end Example // This block will NOT execute 0 1 == if \"This will not print\" print end // This block WILL execute 1 1 == if \"This will print\" print end // Using variables var is_valid bool true is_valid !< is_valid ?> if \"Valid state\" print end while Statement The while loop repeatedly executes a block of code as long as the condition remains non-zero. The loop continues until the condition evaluates to false (zero). Syntax while <condition> do // code to execute repeatedly end Example var counter int counter 0 !< // Initialize counter to 0 while counter 10 < // condition do \"Hello! Iteration: \" print counter print_integer // Print current counter value \"\\n\" print counter copy ?> inc !< // Increment counter end Control flow pattern while \u2192 (condition check) \u2192 do \u2192 end \u2192 while (loop back) \u2502 \u2193 (condition false) (exit loop)","title":"Control Flow Constructs"},{"location":"tutorial/control-flow/#control-flow-constructs","text":"Gofra provides essential control flow constructs for conditional execution and looping.","title":"Control Flow Constructs"},{"location":"tutorial/control-flow/#if-statement","text":"The if statement evaluates a boolean condition and executes the block if the condition is non-zero.","title":"if Statement"},{"location":"tutorial/control-flow/#syntax","text":"<condition> if // code to execute if condition is true end","title":"Syntax"},{"location":"tutorial/control-flow/#example","text":"// This block will NOT execute 0 1 == if \"This will not print\" print end // This block WILL execute 1 1 == if \"This will print\" print end // Using variables var is_valid bool true is_valid !< is_valid ?> if \"Valid state\" print end","title":"Example"},{"location":"tutorial/control-flow/#while-statement","text":"The while loop repeatedly executes a block of code as long as the condition remains non-zero. The loop continues until the condition evaluates to false (zero).","title":"while Statement"},{"location":"tutorial/control-flow/#syntax_1","text":"while <condition> do // code to execute repeatedly end","title":"Syntax"},{"location":"tutorial/control-flow/#example_1","text":"var counter int counter 0 !< // Initialize counter to 0 while counter 10 < // condition do \"Hello! Iteration: \" print counter print_integer // Print current counter value \"\\n\" print counter copy ?> inc !< // Increment counter end","title":"Example"},{"location":"tutorial/control-flow/#control-flow-pattern","text":"while \u2192 (condition check) \u2192 do \u2192 end \u2192 while (loop back) \u2502 \u2193 (condition false) (exit loop)","title":"Control flow pattern"},{"location":"tutorial/memory/","text":"Memory management Memory management is a fundamental aspect of programming. Gofra provides direct memory access operations for loading and storing data. Critical notice Currently, in gofra load and store operations works with always 8-bytes data, so this will cause some overwriting of memory layout, consider that while using critical to memory operations Memory operations Store into memory Stores a value at a specified memory address. Mnemonic: a b -> _ _ Intrinsic: !< Consumes two values from the stack: [address, value] Stores value at memory location address Both values are removed from the stack Syntax <address> <value> !< Examples // Store to a variable var somevar int somevar 1 !< // Store 1 into somevar // Store to calculated address var array int[10] array 0 + 42 !< // Store 42 at array[0] array 8 + 99 !< // Store 99 at array[8] (if int is 4 bytes) Load from memory Stores a value at a specified memory address. Mnemonic: a -> b Intrinsic: ?> Consumes one value from the stack: [address] Loads the value from memory location address Pushes the loaded value onto the stack Syntax <address> ?> Examples // Load from a variable var somevar int somevar 1 !< // Store 1 into somevar somevar ?> // Load value from somevar (pushes 1 onto stack) print_integer // Prints 1 // Load from array element var numbers int[3] numbers 0 + 10 !< // numbers[0] = 10 numbers 8 + 20 !< // numbers[1] = 20 (assuming 8-byte integers) numbers 0 + ?> print // Load and print numbers[0] Memory Size Considerations Pointer Width : Determined by CPU architecture (typically 32-bit or 64-bit) Word Size : Architecture-dependent, affects natural memory alignment Type Sizes : Different data types occupy different amounts of memory Type size reference var b char // 1 byte var i int // 4 or 8 bytes (architecture-dependent) var p *int // 4 or 8 bytes (pointer width)","title":"Memory management"},{"location":"tutorial/memory/#memory-management","text":"Memory management is a fundamental aspect of programming. Gofra provides direct memory access operations for loading and storing data.","title":"Memory management"},{"location":"tutorial/memory/#critical-notice","text":"Currently, in gofra load and store operations works with always 8-bytes data, so this will cause some overwriting of memory layout, consider that while using critical to memory operations","title":"Critical notice"},{"location":"tutorial/memory/#memory-operations","text":"","title":"Memory operations"},{"location":"tutorial/memory/#store-into-memory","text":"Stores a value at a specified memory address. Mnemonic: a b -> _ _ Intrinsic: !< Consumes two values from the stack: [address, value] Stores value at memory location address Both values are removed from the stack","title":"Store into memory"},{"location":"tutorial/memory/#syntax","text":"<address> <value> !<","title":"Syntax"},{"location":"tutorial/memory/#examples","text":"// Store to a variable var somevar int somevar 1 !< // Store 1 into somevar // Store to calculated address var array int[10] array 0 + 42 !< // Store 42 at array[0] array 8 + 99 !< // Store 99 at array[8] (if int is 4 bytes)","title":"Examples"},{"location":"tutorial/memory/#load-from-memory","text":"Stores a value at a specified memory address. Mnemonic: a -> b Intrinsic: ?> Consumes one value from the stack: [address] Loads the value from memory location address Pushes the loaded value onto the stack","title":"Load from memory"},{"location":"tutorial/memory/#syntax_1","text":"<address> ?>","title":"Syntax"},{"location":"tutorial/memory/#examples_1","text":"// Load from a variable var somevar int somevar 1 !< // Store 1 into somevar somevar ?> // Load value from somevar (pushes 1 onto stack) print_integer // Prints 1 // Load from array element var numbers int[3] numbers 0 + 10 !< // numbers[0] = 10 numbers 8 + 20 !< // numbers[1] = 20 (assuming 8-byte integers) numbers 0 + ?> print // Load and print numbers[0]","title":"Examples"},{"location":"tutorial/memory/#memory-size-considerations","text":"Pointer Width : Determined by CPU architecture (typically 32-bit or 64-bit) Word Size : Architecture-dependent, affects natural memory alignment Type Sizes : Different data types occupy different amounts of memory","title":"Memory Size Considerations"},{"location":"tutorial/memory/#type-size-reference","text":"var b char // 1 byte var i int // 4 or 8 bytes (architecture-dependent) var p *int // 4 or 8 bytes (pointer width)","title":"Type size reference"},{"location":"tutorial/stack-management-intrinsics/","text":"Stack management intrinsics For managing an stack you must have some less-or-more complex commands for example like swap or rot , language supports some of them SWAP Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 2 3 swap - // -1 DROP Mnemonics: a -> _ Drops element from stack Example: 2 2 2 drop + // 4, and empty stack COPY Mnemonics: a -> a a Copies element from stack Example: 2 copy // 2 2 on stack","title":"Stack management intrinsics"},{"location":"tutorial/stack-management-intrinsics/#stack-management-intrinsics","text":"For managing an stack you must have some less-or-more complex commands for example like swap or rot , language supports some of them","title":"Stack management intrinsics"},{"location":"tutorial/stack-management-intrinsics/#swap","text":"Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 2 3 swap - // -1","title":"SWAP"},{"location":"tutorial/stack-management-intrinsics/#drop","text":"Mnemonics: a -> _ Drops element from stack Example: 2 2 2 drop + // 4, and empty stack","title":"DROP"},{"location":"tutorial/stack-management-intrinsics/#copy","text":"Mnemonics: a -> a a Copies element from stack Example: 2 copy // 2 2 on stack","title":"COPY"},{"location":"tutorial/structures/","text":"Structures Structs currently is an something like type-definition with proper type checking and field accessors (auto-shift) Defining an structure type struct name field type ... end For example defining an person struct struct Person age int name *char[] end Accessing an structure field Person.age // will push an pointer to an `age` field so you can write / read from it Alignment on CPUs All structures are alignment by default to machine alignment Big Caveats Structs are not passed according to C-FFI ABI Structs have no constructors ... and much more as this feature is being in development an mainly used as drop-in replacement to defining an structs with char[32] or int[2] ... HIR perspective Accessing an structure field will as by default emit PUSH_VARIABLE_ADDRESS HIR operator which is followed by STRUCT_FIELD_OFFSET which is resolved to ADDR(VAR) + FIELD_OFFSET(field) so *struct resolve into *struct.field as auto type inference from structure type LIR perspective Structure type by default is an complex type with collection of field types and their ordering respectfully STRUCT_FIELD_OFFSET is an almost inline-assembly code generation which performs addition right inside runtime","title":"Structures"},{"location":"tutorial/structures/#structures","text":"Structs currently is an something like type-definition with proper type checking and field accessors (auto-shift)","title":"Structures"},{"location":"tutorial/structures/#defining-an-structure-type","text":"struct name field type ... end For example defining an person struct struct Person age int name *char[] end","title":"Defining an structure type"},{"location":"tutorial/structures/#accessing-an-structure-field","text":"Person.age // will push an pointer to an `age` field so you can write / read from it","title":"Accessing an structure field"},{"location":"tutorial/structures/#alignment-on-cpus","text":"All structures are alignment by default to machine alignment","title":"Alignment on CPUs"},{"location":"tutorial/structures/#big-caveats","text":"Structs are not passed according to C-FFI ABI Structs have no constructors ... and much more as this feature is being in development an mainly used as drop-in replacement to defining an structs with char[32] or int[2] ...","title":"Big Caveats"},{"location":"tutorial/structures/#hir-perspective","text":"Accessing an structure field will as by default emit PUSH_VARIABLE_ADDRESS HIR operator which is followed by STRUCT_FIELD_OFFSET which is resolved to ADDR(VAR) + FIELD_OFFSET(field) so *struct resolve into *struct.field as auto type inference from structure type","title":"HIR perspective"},{"location":"tutorial/structures/#lir-perspective","text":"Structure type by default is an complex type with collection of field types and their ordering respectfully STRUCT_FIELD_OFFSET is an almost inline-assembly code generation which performs addition right inside runtime","title":"LIR perspective"},{"location":"tutorial/typecasts/","text":"Type casting There is always situations when you need to cast one type to another to silence errors from typechecker as it quite dumb and may stay on your way For that you have type casting feature (static type casts) only Static type cast Static type cast is an form of casting to an desired type which has no effect on runtime, only compile-time type checking only to statically cast to an type you may do following var a char a typecast int 2 * // by default multiplying an char is not possible typecasts is always in form of: typecast {type_definition_from_scope} You may write any arbitrary and composite / complex types inside typecast (e.g cast to an pointer to an struct)","title":"Type casting"},{"location":"tutorial/typecasts/#type-casting","text":"There is always situations when you need to cast one type to another to silence errors from typechecker as it quite dumb and may stay on your way For that you have type casting feature (static type casts) only","title":"Type casting"},{"location":"tutorial/typecasts/#static-type-cast","text":"Static type cast is an form of casting to an desired type which has no effect on runtime, only compile-time type checking only to statically cast to an type you may do following var a char a typecast int 2 * // by default multiplying an char is not possible typecasts is always in form of: typecast {type_definition_from_scope} You may write any arbitrary and composite / complex types inside typecast (e.g cast to an pointer to an struct)","title":"Static type cast"},{"location":"tutorial/variables/","text":"Variables That page is being written, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions) Variable definitions Variable definitions looks like that: // Primitive type var {name} {type} // Composite type var array {type}[{size_in_elements}] var ptr *{type} var complex **int[32] // pointer to an pointer containing array of integers It must start with var then name and type Primitive and composite types: differences Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of caricature (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} - Structure with set of {primitive|complex} type inside Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type Local and static (global) variable location: differences Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reset // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout Local variables: alignment on CPUs Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Variables"},{"location":"tutorial/variables/#variables","text":"That page is being written, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions)","title":"Variables"},{"location":"tutorial/variables/#variable-definitions","text":"Variable definitions looks like that: // Primitive type var {name} {type} // Composite type var array {type}[{size_in_elements}] var ptr *{type} var complex **int[32] // pointer to an pointer containing array of integers It must start with var then name and type","title":"Variable definitions"},{"location":"tutorial/variables/#primitive-and-composite-types-differences","text":"Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of caricature (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} - Structure with set of {primitive|complex} type inside Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type","title":"Primitive and composite types: differences"},{"location":"tutorial/variables/#local-and-static-global-variable-location-differences","text":"Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reset // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout","title":"Local and static (global) variable location: differences"},{"location":"tutorial/variables/#local-variables-alignment-on-cpus","text":"Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Local variables: alignment on CPUs"}]}