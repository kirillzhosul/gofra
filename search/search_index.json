{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gofra [beta] A Stack-based compiled programming language. The project is made not for competing with other languages, rather it is another incomplete language almost same like others. Overview Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ). Quick start Here's a simple \"Hello, World!\" example: include \"std\" func void main \"Hello, World!\" println end Features Native - Compiles to native machine code C -like - Close to C, but has a few more high-level abstraction ( for in , type generics ) C FFI - Seamless integration with C -FFI libraries Low-level - Write unsafe, low-level code with direct memory access Type System - Validate types at compile time, has compile-time warnings (Partial generics supports, typechecker) Library - By default has support for math , random , network and other libraries First class functions - Has support, and lambda definitions (no closures/capturing yet) Showcase Pong Game ( examples/03_pong.gof ) Simple HTTP server ( examples/04_http_server.gof ) Milestones Platform support Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target. Full: AArch64 macOS (Darwin) Partial, buggy: x86_64 (Linux), WASM (Windows x86_64 is must be supported soon, requires contributors) Pre requirements Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x For x86_64 / ARM targets: - GNU/Mach-O Linker (ld) - For linking compiled objects - Assembler (as) - Typically included with Clang LLVM compiler For WASM target: - - WABT toolkit ( wat2wasm ) Installation For full installation steps, please visit Installation page. Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"About"},{"location":"#gofra-beta","text":"A Stack-based compiled programming language. The project is made not for competing with other languages, rather it is another incomplete language almost same like others.","title":"Gofra [beta]"},{"location":"#overview","text":"Gofra is a concatenative (stack-based) programming language that compiles to native code. Programs are written using Reverse Polish notation , where operations follow their operands (e.g 2 + 2 is 2 2 + ).","title":"Overview"},{"location":"#quick-start","text":"Here's a simple \"Hello, World!\" example: include \"std\" func void main \"Hello, World!\" println end","title":"Quick start"},{"location":"#features","text":"Native - Compiles to native machine code C -like - Close to C, but has a few more high-level abstraction ( for in , type generics ) C FFI - Seamless integration with C -FFI libraries Low-level - Write unsafe, low-level code with direct memory access Type System - Validate types at compile time, has compile-time warnings (Partial generics supports, typechecker) Library - By default has support for math , random , network and other libraries First class functions - Has support, and lambda definitions (no closures/capturing yet)","title":"Features"},{"location":"#showcase","text":"Pong Game ( examples/03_pong.gof ) Simple HTTP server ( examples/04_http_server.gof )","title":"Showcase"},{"location":"#milestones","text":"","title":"Milestones"},{"location":"#platform-support","text":"Gofra currently supports native compilation (no cross-compilation yet). You must compile on the same platform as your target. Full: AArch64 macOS (Darwin) Partial, buggy: x86_64 (Linux), WASM (Windows x86_64 is must be supported soon, requires contributors)","title":"Platform support"},{"location":"#pre-requirements","text":"Before installing Gofra, ensure you have the following tools available system-wide: Python >3.12.x For x86_64 / ARM targets: - GNU/Mach-O Linker (ld) - For linking compiled objects - Assembler (as) - Typically included with Clang LLVM compiler For WASM target: - - WABT toolkit ( wat2wasm )","title":"Pre requirements"},{"location":"#installation","text":"For full installation steps, please visit Installation page. Gofra is distributed as single Python-based toolchain. To install: (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Installation"},{"location":"editors/","text":"IDE and Editor support Enhance your Gofra development experience with official and unofficial extensions for your favorite code editor. These extensions provide syntax highlighting, code snippets, and useful commands to streamline your workflow. Vim / Neovim The Gofra plugin for Vim is available on GitHub and can be easily installed. Huge thanks to Stepan Zubkov for developing an extension! Installation Please refer to their respective documentation using the repository URL: github.com/stepanzubkov/gofra.vim Features Syntax Highlighting: Support for .gof file syntax. Automatic indentation Visual Studio Code The extension is currently available by installing it directly from the source. We are working on publishing it to the Visual Studio Code Marketplace for easier installation. Manual Installation from Source Clone the Repository: bash git clone https://github.com/kirillzhosul/gofra cd gofra/editors/vscode Package the Extension: You need to have Node.js and the vsce (Visual Studio Code Extensions) tool installed. bash npm install -g @vscode/vsce vsce package This command will create a .vsix file in the directory. Install in VS Code: Open VS Code. Go to the Extensions view (Ctrl+Shift+X / Cmd+Shift+X). Click the \"...\" menu in the top-right of the Extensions panel and select Install from VSIX.... Navigate to and select the .vsix file you created in the previous step. Reload VS Code when prompted. Features Syntax Highlighting: Support for .gof file syntax. Other Editors & Contributing Support for your editor not listed here? We welcome contributions! The source code for all editor extensions is located in the editors directory of the main Gofra repository or your own repository if you wish to separate that. If you'd like to create an extension for another editor (such as Sublime Text, IntelliJ IDEA, or Emacs), please use the existing implementations as a reference. Check the editors directory in the Gofra source code . Feel free to open an issue on GitHub to discuss your plans for a new extension. Submit a pull request with your new extension, and we'll be happy to include it here!","title":"IDE and Editor support"},{"location":"editors/#ide-and-editor-support","text":"Enhance your Gofra development experience with official and unofficial extensions for your favorite code editor. These extensions provide syntax highlighting, code snippets, and useful commands to streamline your workflow.","title":"IDE and Editor support"},{"location":"editors/#vim-neovim","text":"The Gofra plugin for Vim is available on GitHub and can be easily installed. Huge thanks to Stepan Zubkov for developing an extension!","title":"Vim / Neovim"},{"location":"editors/#installation","text":"Please refer to their respective documentation using the repository URL: github.com/stepanzubkov/gofra.vim","title":"Installation"},{"location":"editors/#features","text":"Syntax Highlighting: Support for .gof file syntax. Automatic indentation","title":"Features"},{"location":"editors/#visual-studio-code","text":"The extension is currently available by installing it directly from the source. We are working on publishing it to the Visual Studio Code Marketplace for easier installation.","title":"Visual Studio Code"},{"location":"editors/#manual-installation-from-source","text":"Clone the Repository: bash git clone https://github.com/kirillzhosul/gofra cd gofra/editors/vscode Package the Extension: You need to have Node.js and the vsce (Visual Studio Code Extensions) tool installed. bash npm install -g @vscode/vsce vsce package This command will create a .vsix file in the directory. Install in VS Code: Open VS Code. Go to the Extensions view (Ctrl+Shift+X / Cmd+Shift+X). Click the \"...\" menu in the top-right of the Extensions panel and select Install from VSIX.... Navigate to and select the .vsix file you created in the previous step. Reload VS Code when prompted.","title":"Manual Installation from Source"},{"location":"editors/#features_1","text":"Syntax Highlighting: Support for .gof file syntax.","title":"Features"},{"location":"editors/#other-editors-contributing","text":"Support for your editor not listed here? We welcome contributions! The source code for all editor extensions is located in the editors directory of the main Gofra repository or your own repository if you wish to separate that. If you'd like to create an extension for another editor (such as Sublime Text, IntelliJ IDEA, or Emacs), please use the existing implementations as a reference. Check the editors directory in the Gofra source code . Feel free to open an issue on GitHub to discuss your plans for a new extension. Submit a pull request with your new extension, and we'll be happy to include it here!","title":"Other Editors &amp; Contributing"},{"location":"installation/","text":"Installation Pre requirements Gofra is a Python-based toolchain, so you only require a Python installation. However, as a toolchain-compiled code, it depends on the target-specific linker and assembler. Python >3.12.x available as python or python3 command For x86_64 / ARM targets: - - GNU/Mach-O Linker (ld) - For linking compiled objects - - Assembler (as) - Typically included with Clang LLVM compiler For WASM target: - - WABT toolkit ( wat2wasm ) Gofra is distributed as single Python-based toolchain. To install: Install (Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help Development installation (Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate the local gofra command over the system-wide gofra if you are inside the environment (e.g. poetry shell ))","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#pre-requirements","text":"Gofra is a Python-based toolchain, so you only require a Python installation. However, as a toolchain-compiled code, it depends on the target-specific linker and assembler. Python >3.12.x available as python or python3 command For x86_64 / ARM targets: - - GNU/Mach-O Linker (ld) - For linking compiled objects - - Assembler (as) - Typically included with Clang LLVM compiler For WASM target: - - WABT toolkit ( wat2wasm ) Gofra is distributed as single Python-based toolchain. To install:","title":"Pre requirements"},{"location":"installation/#install","text":"(Step 1): Install toolchain pip install gofra (Step 2): Verify Installation gofra --help","title":"Install"},{"location":"installation/#development-installation","text":"(Step 1): Clone the repository git clone https://github.com/kirillzhosul/gofra.git cd gofra (Step 2): Verify installation cd gofra python -m gofra --help (Step 3): Install dependencies ( Poetry required) # In repository root poetry install --with dev,docs This will install Ruff and MkDocs available as: # Serve documentation mkdocs serve # Lint source code ruff . (It will also propagate the local gofra command over the system-wide gofra if you are inside the environment (e.g. poetry shell ))","title":"Development installation"},{"location":"advanced/","text":"Advanced usage and tutorials Preprocessor FFI Optimizations Type checker Toolchain Architecture Function Attributes Type definition Generic Types WebAssembly First Class Functions / Lambdas / Function Type","title":"Advanced"},{"location":"advanced/#advanced-usage-and-tutorials","text":"","title":"Advanced usage and tutorials"},{"location":"advanced/#preprocessor","text":"","title":"Preprocessor"},{"location":"advanced/#ffi","text":"","title":"FFI"},{"location":"advanced/#optimizations","text":"","title":"Optimizations"},{"location":"advanced/#type-checker","text":"","title":"Type checker"},{"location":"advanced/#toolchain-architecture","text":"","title":"Toolchain Architecture"},{"location":"advanced/#function-attributes","text":"","title":"Function Attributes"},{"location":"advanced/#type-definition","text":"","title":"Type definition"},{"location":"advanced/#generic-types","text":"","title":"Generic Types"},{"location":"advanced/#webassembly","text":"","title":"WebAssembly"},{"location":"advanced/#first-class-functions-lambdas-function-type","text":"","title":"First Class Functions / Lambdas / Function Type"},{"location":"advanced/ffi/","text":"FFI (Foreign Function Interface) Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI. extern marker Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[*char[]] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error Type contracts for FFI To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you Variadic arguments (type contracts) For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments) Linker stage For letting linker know about that dependencies (Libraries with FFI), you can pass -l flag(s) to the compiler For example linking with raylib and using their functions: -lraylib ( -L/opt/homebrew/lib if search directory was not found with pkgconfig ( --no-pkg-config ))","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#ffi-foreign-function-interface","text":"Read about FFI at Wikipedia This documentation page is written for AARCH64_MacOS target and may be irrelevant for some underneath implementations on different targets, like FFI naming conventions on different assemblers Gofra is capable of calling functions that written in other languages and externally defined, for example using libraries written for/in C or other language, or using system libraries. To do that assembler after code generation at linker stage should be acknowledged of external libraries (via CLI linker flags) and Gofra source code should specify which functions being external for FFI.","title":"FFI (Foreign Function Interface)"},{"location":"advanced/ffi/#extern-marker","text":"Functions marked with extern keyword/marker will be treated as externally defined via FFI for example external function puts from libc is declared as: extern func int _puts[*char[]] This is written according to libc library C interface: int puts(const char *s){ ... } External functions in Gofra CANNOT have any tokens inside otherwise compiler will throw an error","title":"extern marker"},{"location":"advanced/ffi/#type-contracts-for-ffi","text":"To specify which data is expected for and from external function you specify type contract for that functions (like default functions in Gofra) Every argument will be treated by compiler and will be passed to that function, as well as external function return data will be pushed onto stack for you","title":"Type contracts for FFI"},{"location":"advanced/ffi/#variadic-arguments-type-contracts","text":"For now, there is no way to pass variadic arguments to external function (Hack or workaround for that is only to create non-variadic wrappers with different number of arguments to pass to underlying external function which type contract is expanded for max required amount of arguments)","title":"Variadic arguments (type contracts)"},{"location":"advanced/ffi/#linker-stage","text":"For letting linker know about that dependencies (Libraries with FFI), you can pass -l flag(s) to the compiler For example linking with raylib and using their functions: -lraylib ( -L/opt/homebrew/lib if search directory was not found with pkgconfig ( --no-pkg-config ))","title":"Linker stage"},{"location":"advanced/first-class-functions/","text":"First-class functions (Lambdas) Gofra is an language with first-class functions it does support passing functions as arguments to other functions, returning them as return value from other functions and store into memory Function type To work with function as types/values you need to interact with Function Type it is defined same as default functions except, type expression goes into type block: // Define an type that describes function (Function Type) type F func void _[] type F func int _[int a, int b] type F func int _[int, int] func void f[F function] // Use that type func void f[func void _[int, int] function] // Inline function type var f F; // Holds function While defining an function type, name and parameter names is dropped within type holder, which means you can define auxiliary name / parameter names, but general convention is to name function _ . Treating functions as Function Type pointer_of_proc allows to acquire Function Type from specified function e.g: func void f[int a] ... end func void main[] var f func void _[int]; &f pointer_of_proc f !< end This keyword pushes Function Type (e.g function pointer) onto the stack, allowing storing and passing it to other functions Lambda function definition You can define function within another one, by using lambda function definition like so: // Create function that return another function type F_T func int _[int, int] func F_T create_function[] lambda func int _[int, int] + // sum arguments end return end lambda definition always returns an Function Type as pointer of your fresh lambda function Calling an Function Type You cannot directly call an pointer (Function Type), you, unfortunately must store it inside some holder, and use call keyword/operator func void f[] ... end func void main[] var v func void _[]; &v pointer_of_proc f !< call v end functools Gofra provides general high-order functions within that module ( std/functools.gof ) - i_map - i_reduce This is simple primitives that is extensible for your actual usage Closure Proposal Closures is yet not available in Gofra , lambda functions is not capturing-lambda-functions","title":"First-class functions (Lambdas)"},{"location":"advanced/first-class-functions/#first-class-functions-lambdas","text":"Gofra is an language with first-class functions it does support passing functions as arguments to other functions, returning them as return value from other functions and store into memory","title":"First-class functions (Lambdas)"},{"location":"advanced/first-class-functions/#function-type","text":"To work with function as types/values you need to interact with Function Type it is defined same as default functions except, type expression goes into type block: // Define an type that describes function (Function Type) type F func void _[] type F func int _[int a, int b] type F func int _[int, int] func void f[F function] // Use that type func void f[func void _[int, int] function] // Inline function type var f F; // Holds function While defining an function type, name and parameter names is dropped within type holder, which means you can define auxiliary name / parameter names, but general convention is to name function _ .","title":"Function type"},{"location":"advanced/first-class-functions/#treating-functions-as-function-type","text":"pointer_of_proc allows to acquire Function Type from specified function e.g: func void f[int a] ... end func void main[] var f func void _[int]; &f pointer_of_proc f !< end This keyword pushes Function Type (e.g function pointer) onto the stack, allowing storing and passing it to other functions","title":"Treating functions as Function Type"},{"location":"advanced/first-class-functions/#lambda-function-definition","text":"You can define function within another one, by using lambda function definition like so: // Create function that return another function type F_T func int _[int, int] func F_T create_function[] lambda func int _[int, int] + // sum arguments end return end lambda definition always returns an Function Type as pointer of your fresh lambda function","title":"Lambda function definition"},{"location":"advanced/first-class-functions/#calling-an-function-type","text":"You cannot directly call an pointer (Function Type), you, unfortunately must store it inside some holder, and use call keyword/operator func void f[] ... end func void main[] var v func void _[]; &v pointer_of_proc f !< call v end","title":"Calling an Function Type"},{"location":"advanced/first-class-functions/#functools","text":"Gofra provides general high-order functions within that module ( std/functools.gof ) - i_map - i_reduce This is simple primitives that is extensible for your actual usage","title":"functools"},{"location":"advanced/first-class-functions/#closure-proposal","text":"Closures is yet not available in Gofra , lambda functions is not capturing-lambda-functions","title":"Closure Proposal"},{"location":"advanced/function-attributes/","text":"Function Attributes Function attributes in Gofra are defined like so: FunctionDef = {\"pub\" | \"extern\" | \"no_return\" | \"inline}, \"func\", ...FunctionRestDef Here is description of each attribute no_return attribute Marks function as having no possible way out, for example exit system function, these function must has no return value Compiler will warn you if you have function that always calls to no_return functions, and emit possible other warnings no-return allows to emit general compiler warnings/errors and perform possible optimizations, mostly used in compiler library, but useful if you calling exit function and has nothing more This checks appears only at compile-time and has no effect on runtime no_return func void x[] // Must has no way out end func void x1[] call exit // warning, always calling to `no_return` function - propagate attribute 2 2 + drop // warning, unreachable code, and allows to apply optimizations like DCE end func void x1[] false if == call exit // may have conditional `no_return` calls without any warning end end inline attribute Functions that marked as inline has no real-call in runtime, it expands their tokens right into caller block These function cannot have local variables as may pollute original caller blocks TODO: For now, inline functions has lack of compiler-time checks (e.g typechecking), and may be not so safe to use, and are hard to debug, non-inlineable functions are always better now For more information what is inlining and optimization look into Optimizations documentation For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end extern attribute Functions marked with extern attribute will be treated as externally defined via FFI (Gofra ones, other C-FFI) for example external function puts from libc is declared as: extern func int _puts[*char[]] This means function symbol _puts is not available inside current object file (co-program) but will appear later at linkage step within another object file (library) For more information what is FFI look into FFI documentation pub attribute Function marked with pub attribute are opposite to extern ones - they expose this function symbol to object file and allow other object files to link with it","title":"Function Attributes"},{"location":"advanced/function-attributes/#function-attributes","text":"Function attributes in Gofra are defined like so: FunctionDef = {\"pub\" | \"extern\" | \"no_return\" | \"inline}, \"func\", ...FunctionRestDef Here is description of each attribute","title":"Function Attributes"},{"location":"advanced/function-attributes/#no_return-attribute","text":"Marks function as having no possible way out, for example exit system function, these function must has no return value Compiler will warn you if you have function that always calls to no_return functions, and emit possible other warnings no-return allows to emit general compiler warnings/errors and perform possible optimizations, mostly used in compiler library, but useful if you calling exit function and has nothing more This checks appears only at compile-time and has no effect on runtime no_return func void x[] // Must has no way out end func void x1[] call exit // warning, always calling to `no_return` function - propagate attribute 2 2 + drop // warning, unreachable code, and allows to apply optimizations like DCE end func void x1[] false if == call exit // may have conditional `no_return` calls without any warning end end","title":"no_return attribute"},{"location":"advanced/function-attributes/#inline-attribute","text":"Functions that marked as inline has no real-call in runtime, it expands their tokens right into caller block These function cannot have local variables as may pollute original caller blocks TODO: For now, inline functions has lack of compiler-time checks (e.g typechecking), and may be not so safe to use, and are hard to debug, non-inlineable functions are always better now For more information what is inlining and optimization look into Optimizations documentation For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end","title":"inline attribute"},{"location":"advanced/function-attributes/#extern-attribute","text":"Functions marked with extern attribute will be treated as externally defined via FFI (Gofra ones, other C-FFI) for example external function puts from libc is declared as: extern func int _puts[*char[]] This means function symbol _puts is not available inside current object file (co-program) but will appear later at linkage step within another object file (library) For more information what is FFI look into FFI documentation","title":"extern attribute"},{"location":"advanced/function-attributes/#pub-attribute","text":"Function marked with pub attribute are opposite to extern ones - they expose this function symbol to object file and allow other object files to link with it","title":"pub attribute"},{"location":"advanced/function-type/","text":"Function type and Function pointer pointer_of_proc Pushes pointer of specified function onto the stack func void f[] ... end pointer_of_proc f // () -> void Defining an function type func void f[] ... end type FunctionType func void _[] var x FunctionType; var v func void _[]; Calling from function type holder func void f[] ... end func void main[] var v func void _[]; &v pointer_of_proc f !< call v end","title":"Function type and Function pointer"},{"location":"advanced/function-type/#function-type-and-function-pointer","text":"","title":"Function type and Function pointer"},{"location":"advanced/function-type/#pointer_of_proc","text":"Pushes pointer of specified function onto the stack func void f[] ... end pointer_of_proc f // () -> void","title":"pointer_of_proc"},{"location":"advanced/function-type/#defining-an-function-type","text":"func void f[] ... end type FunctionType func void _[] var x FunctionType; var v func void _[];","title":"Defining an function type"},{"location":"advanced/function-type/#calling-from-function-type-holder","text":"func void f[] ... end func void main[] var v func void _[]; &v pointer_of_proc f !< call v end","title":"Calling from function type holder"},{"location":"advanced/generic-types/","text":"Generic Types This page uses some general terminology of Type Theory for Type Systems Generics in Gofra are form of lazy template for any concrete type Current limitations and known problems These must be resolved later - Applying generic type requires type parameter name - Cannot define generic for function - Cannot apply/reference generic in form of defining another generic Concrete types By default any primitives type ( int , char , ...) are concrete types, this means they have known size in bytes, and structure field / variable can has type of concrete kind. Composite types (Pointers, Arrays) with primitive types also concrete - they has known size directly Only concrete types may be used inside any non type-expression definition (e.g type ) form (unless for Generics they must applied into Concrete types with Generic Type Parameters) Defining an generic type // Generic defined as *Identity* (apply Type Parameter to concrete type of same type) type Identity{T} = T // Pointer to generic type parameter type XT{T} = *T // Array of type T with size N (where N is value type parameter) type Array{T, N} = T[N] // Sort of dynamic array / slice view with generics // Struct will be different each application into concrete one struct Slice{T, K} data *T[K] len int end Applying generic types into concrete one As far you know - generic types cannot be used outside of type definition, you need to apply them otherwise Applying generic type - is same as transforming it to generic one with known size and types type Identity{T} = T // Applying generic type into concrete (expanding type parameters) var HasConcreteType = Identity{T = int} // typeof is `int` // With value type arguments var arr Array{T = int, N = 3} Terminology Type Parameter : T in Identity{T} Type Argument : int in Identity{T = int} Generic Type : Identity{T} (unapplied) Applied Generic : Identity{T = int} (concrete) Concrete Type : Fully resolved type with known size","title":"Generic Types"},{"location":"advanced/generic-types/#generic-types","text":"","title":"Generic Types"},{"location":"advanced/generic-types/#this-page-uses-some-general-terminology-of-type-theory-for-type-systems","text":"Generics in Gofra are form of lazy template for any concrete type","title":"This page uses some general terminology of Type Theory for Type Systems"},{"location":"advanced/generic-types/#current-limitations-and-known-problems","text":"These must be resolved later - Applying generic type requires type parameter name - Cannot define generic for function - Cannot apply/reference generic in form of defining another generic","title":"Current limitations and known problems"},{"location":"advanced/generic-types/#concrete-types","text":"By default any primitives type ( int , char , ...) are concrete types, this means they have known size in bytes, and structure field / variable can has type of concrete kind. Composite types (Pointers, Arrays) with primitive types also concrete - they has known size directly Only concrete types may be used inside any non type-expression definition (e.g type ) form (unless for Generics they must applied into Concrete types with Generic Type Parameters)","title":"Concrete types"},{"location":"advanced/generic-types/#defining-an-generic-type","text":"// Generic defined as *Identity* (apply Type Parameter to concrete type of same type) type Identity{T} = T // Pointer to generic type parameter type XT{T} = *T // Array of type T with size N (where N is value type parameter) type Array{T, N} = T[N] // Sort of dynamic array / slice view with generics // Struct will be different each application into concrete one struct Slice{T, K} data *T[K] len int end","title":"Defining an generic type"},{"location":"advanced/generic-types/#applying-generic-types-into-concrete-one","text":"As far you know - generic types cannot be used outside of type definition, you need to apply them otherwise Applying generic type - is same as transforming it to generic one with known size and types type Identity{T} = T // Applying generic type into concrete (expanding type parameters) var HasConcreteType = Identity{T = int} // typeof is `int` // With value type arguments var arr Array{T = int, N = 3}","title":"Applying generic types into concrete one"},{"location":"advanced/generic-types/#terminology","text":"Type Parameter : T in Identity{T} Type Argument : int in Identity{T = int} Generic Type : Identity{T} (unapplied) Applied Generic : Identity{T = int} (concrete) Concrete Type : Fully resolved type with known size","title":"Terminology"},{"location":"advanced/module-import-system/","text":"Module and imports system [This is WIP feature, both documentation and implementation is unfinished, use at your own risk] Currently, Gofra has 2 ways of injecting code from other files, C/C++ way with preprocessor: #include (read more at preprocessor page), and new Work-In-Progress module system that must be enabled with libgofra FEATURE_ALLOW_MODULES flag Definition of an module Module in Gofra context - is an single file that is treated as module, and compiled internally separately into its own object file. For example lets define two modules: // > a.gof import b; func void main[] call b.hello_world; end // > b.gof #include \"std\" pub func void hello_world[] \"Hello, World!\" call println end First one, a , is our root module for compilation - we compile from gofra a.gof , as it is defines entry point ( main ) Under the hood, Gofra will start from compiling a.gof , find import statement and try to process b.gof module, when it is processed, compiler, and a.gof processing especially, knowns that it depends on b.gof and call to b.hello_world must be resolved (public function is available for root module), after parsing and processing, it will be compiled to a.o (core object file) and a$mod_dependencies (inside cache), which holds b.o that is linked against root a.o to single a executable! Importing an module import a; // implicitly `a.gof` as `a` import a as my_module; // implicitly `a.gof` as `my_module` import \"my_file.gof\" as m; // explicitly `my_file.gof` as `m` //(in both above string allowed) Visibility of symbols By default, all symbols treated as private you must mark exposed symbols via pub attribute modifier Visibility Description Public Symbol is available both inside own module and its dependant modules Private Symbol is available only within its own module If you try to call private symbol from other module, compiler will emit an error and stop compilation: Tried to call private/internal function symbol ... (defined at ...) from module named as `...` (import from ...): Either make it public or not use prohibited symbols! Known problems and limitations Inline functions cannot be exposed Types, definition and structs cannot be exposed Cannot alias import symbol Cannot partially import symbols from module REPL does not supports modules Testkit does not supports modules Possibly, pollution of internal macros registry when including other files (TBD) Duplicate symbol reference (no implicit name mangling) (only linear dependency graph is possible to resolve for now) Resolving circular dependencies TBD (circular dependencies drop compiler, not implemented in any way) Module symbol mangling for external linkage and FFI Currently, there is no mangling, but it is temporary problem/luck This prohibits to have non-linear/real graph dependencies, yet allows simple FFI calls Later (TODO), symbols will be always/conditionally mangled for resolving problems of duplicate symbols in object files Order of searching modules Search algorithm is same as preprocessor include: - Try module name from current directory - Try CLI toolchain directory - Try include paths (obscured with CLI flag for preprocessor) Incremental compilation By default, modules never compiled incrementally and always being being rebuilt, this behavior can be overridden with --incremental flag, internally compiler decide to not rebuild based on modified time difference from artifact (object/assembly file) and original module file (*.gof) Order of dependencies Dependencies compiled and resolved based on order from source e.g if a import b and then c with e compiled will build linear graph like this: a -> b -+-> c | +-> d There is some sort of DAG topological sorting applied to compiled modules (a->b->c->d), final resolving is on back of LTO and linkage. Notice that currently, possible of recompiling modules when there is same dependency over an graph on multiple nodes Typechecking and optimizations for dependencies Typechecking is applied to every module, each function symbol is re-typechecked on compilation For optimizer passes, firstly Gofra traverses and optimizes dependencies in topological sort order (DAG TSO), then applies final optimizer pass for root module (rule: dependencies first, to perform expensive and high-level optimizations within root module over already-optimized dependencies)","title":"Module and imports system"},{"location":"advanced/module-import-system/#module-and-imports-system","text":"[This is WIP feature, both documentation and implementation is unfinished, use at your own risk] Currently, Gofra has 2 ways of injecting code from other files, C/C++ way with preprocessor: #include (read more at preprocessor page), and new Work-In-Progress module system that must be enabled with libgofra FEATURE_ALLOW_MODULES flag","title":"Module and imports system"},{"location":"advanced/module-import-system/#definition-of-an-module","text":"Module in Gofra context - is an single file that is treated as module, and compiled internally separately into its own object file. For example lets define two modules: // > a.gof import b; func void main[] call b.hello_world; end // > b.gof #include \"std\" pub func void hello_world[] \"Hello, World!\" call println end First one, a , is our root module for compilation - we compile from gofra a.gof , as it is defines entry point ( main ) Under the hood, Gofra will start from compiling a.gof , find import statement and try to process b.gof module, when it is processed, compiler, and a.gof processing especially, knowns that it depends on b.gof and call to b.hello_world must be resolved (public function is available for root module), after parsing and processing, it will be compiled to a.o (core object file) and a$mod_dependencies (inside cache), which holds b.o that is linked against root a.o to single a executable!","title":"Definition of an module"},{"location":"advanced/module-import-system/#importing-an-module","text":"import a; // implicitly `a.gof` as `a` import a as my_module; // implicitly `a.gof` as `my_module` import \"my_file.gof\" as m; // explicitly `my_file.gof` as `m` //(in both above string allowed)","title":"Importing an module"},{"location":"advanced/module-import-system/#visibility-of-symbols","text":"By default, all symbols treated as private you must mark exposed symbols via pub attribute modifier Visibility Description Public Symbol is available both inside own module and its dependant modules Private Symbol is available only within its own module If you try to call private symbol from other module, compiler will emit an error and stop compilation: Tried to call private/internal function symbol ... (defined at ...) from module named as `...` (import from ...): Either make it public or not use prohibited symbols!","title":"Visibility of symbols"},{"location":"advanced/module-import-system/#known-problems-and-limitations","text":"Inline functions cannot be exposed Types, definition and structs cannot be exposed Cannot alias import symbol Cannot partially import symbols from module REPL does not supports modules Testkit does not supports modules Possibly, pollution of internal macros registry when including other files (TBD) Duplicate symbol reference (no implicit name mangling) (only linear dependency graph is possible to resolve for now)","title":"Known problems and limitations"},{"location":"advanced/module-import-system/#resolving-circular-dependencies","text":"TBD (circular dependencies drop compiler, not implemented in any way)","title":"Resolving circular dependencies"},{"location":"advanced/module-import-system/#module-symbol-mangling-for-external-linkage-and-ffi","text":"Currently, there is no mangling, but it is temporary problem/luck This prohibits to have non-linear/real graph dependencies, yet allows simple FFI calls Later (TODO), symbols will be always/conditionally mangled for resolving problems of duplicate symbols in object files","title":"Module symbol mangling for external linkage and FFI"},{"location":"advanced/module-import-system/#order-of-searching-modules","text":"Search algorithm is same as preprocessor include: - Try module name from current directory - Try CLI toolchain directory - Try include paths (obscured with CLI flag for preprocessor)","title":"Order of searching modules"},{"location":"advanced/module-import-system/#incremental-compilation","text":"By default, modules never compiled incrementally and always being being rebuilt, this behavior can be overridden with --incremental flag, internally compiler decide to not rebuild based on modified time difference from artifact (object/assembly file) and original module file (*.gof)","title":"Incremental compilation"},{"location":"advanced/module-import-system/#order-of-dependencies","text":"Dependencies compiled and resolved based on order from source e.g if a import b and then c with e compiled will build linear graph like this: a -> b -+-> c | +-> d There is some sort of DAG topological sorting applied to compiled modules (a->b->c->d), final resolving is on back of LTO and linkage. Notice that currently, possible of recompiling modules when there is same dependency over an graph on multiple nodes","title":"Order of dependencies"},{"location":"advanced/module-import-system/#typechecking-and-optimizations-for-dependencies","text":"Typechecking is applied to every module, each function symbol is re-typechecked on compilation For optimizer passes, firstly Gofra traverses and optimizes dependencies in topological sort order (DAG TSO), then applies final optimizer pass for root module (rule: dependencies first, to perform expensive and high-level optimizations within root module over already-optimized dependencies)","title":"Typechecking and optimizations for dependencies"},{"location":"advanced/optimizations/","text":"Optimizer and optimizations Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now) Optimizer level features Optimization Minimum level DCE 1 Function inlining 1 Optimization features (passes) Here is an list of all possible optimizations that optimizer may apply DCE (Dead-Code-Elimination) Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searches for functions that is not being called at least once and removes them from final IR so them does not appear in final binary as being unused. Does not removes public functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function. Function inlining Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recursive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase final binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-and-optimizations","text":"Gofra has builtin optimizer that helps optimize your code (from top-level HIR optimizations to low-level LIR ones according to selected target) By default optimizer and all optimizations is disabled for development assistance and decreased build time, optimizations may be enabled via CLI using -O{N} flag with desired level of optimizations ( -01 , -02 is supported for now)","title":"Optimizer and optimizations"},{"location":"advanced/optimizations/#optimizer-level-features","text":"Optimization Minimum level DCE 1 Function inlining 1","title":"Optimizer level features"},{"location":"advanced/optimizations/#optimization-features-passes","text":"Here is an list of all possible optimizations that optimizer may apply","title":"Optimization features (passes)"},{"location":"advanced/optimizations/#dce-dead-code-elimination","text":"Minimum optimization level: 1 ( -O1 ) Impact: Reduced binary size Flag: -fdce , fno-dce DCE searches for functions that is not being called at least once and removes them from final IR so them does not appear in final binary as being unused. Does not removes public functions as their usage is outside of an Gofra program. For example this function may be removed by DCE // [Additionally, most of binary size comes for example from libraries which gives you a lot of functions] include \"std\" func void test_function[] // This function is unused so it will be safely remove ... end func void main[] \"Hello, World!\\n\" print end --dce-max-iterations affects max iterations that DCE may perform, by default it is around 128 which is mostly fine, for example if function is removed, optimizer must review program code again as that function may reference other functions which is became unused due to removed that initial function.","title":"DCE (Dead-Code-Elimination)"},{"location":"advanced/optimizations/#function-inlining","text":"Minimum optimization level: 1 ( -O1 ) Impact: Increased binary size , Increased performance Flag: -finline-functions , fno-inline-functions Function inlining automatically marks simple / small functions as inlineable and resolves their usages after that marking. Inlining is not performed for recursive functions, as it will break not only the code but also optimizer itself (while resolving inline function reference infinite amount of iterations until threshold) For example: func int reduce_pairs[int,int,int,int] + + + end func void main[] 1 2 3 4 reduce_pairs // yields 10 end // After inlining this is becomes: inline func int reduce_pairs[int,int,int,int] + + + end // And main is reduced to: func void main[] 1 2 3 4 + + + // yields 10 end // [which is also may be optimized using CF (constant-folding)] --inline-functions-max-iterations affects max iterations for function inlining to search for new inlined function usage in other functions. Low limit will result into unknown function call at assembler stage. This may slightly increase final binary size --inline-functions-max-operators affects max amount of operators to treat function as inlineable. Setting big number will lead to almost all function will be treated as inline ones.","title":"Function inlining"},{"location":"advanced/preprocessor/","text":"Preprocessor Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occurred at next possible stage: parser) All preprocessor keywords begins with # Include system and #include Most of the time you do not write program in a single file, or require additional code from libraries, in Gofra #include allows to straightforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Include system is like recursive so all definitions of an preprocessor will be available at include side Module include In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries Searching strategy At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories Macro definitions To define an macro you can use #define preprocessor directive (and #undef ) correspondingly #define MACRO 2 // macro containing an token 2 after that you are allowed to inject that macro inside your code MACRO MACRO + // 4 (2 2 +) Propagation via CLI You can use -D flag to define an macro from CLI which is useful for something like debug flags -Ddebug=1 (define an macro debug with value 1) Definition checking at preprocessor stage You can use #ifdef , #ifndef and #endif for checking definition of an macro #ifdef DEBUG // only be compiled if DEBUG macro is present #endif Toolchain propagated macros and target specific macros By default Gofra provides two macros: OS_{NAME} and ARCH_{NAME} For example while compiling to Darwin on ARM64 there will be 2 macros available -> OS_DARWIN and ARCH_ARM64","title":"Preprocessor"},{"location":"advanced/preprocessor/#preprocessor","text":"Preprocessor is an stage in within compilation (simplified) that works with lexer tokens (e.g raw text) and resolves references to preprocessor itself (e.g #include is preprocessor only directive and will throw an error if occurred at next possible stage: parser) All preprocessor keywords begins with #","title":"Preprocessor"},{"location":"advanced/preprocessor/#include-system-and-include","text":"Most of the time you do not write program in a single file, or require additional code from libraries, in Gofra #include allows to straightforward include whole text of an file (with some additional file path resolving and include-once strategy) #include \"sum.gof\" func void main 2 2 sum // sum is defined at sum.gof end Include system is like recursive so all definitions of an preprocessor will be available at include side","title":"Include system and #include"},{"location":"advanced/preprocessor/#module-include","text":"In Gofra, there is convention that when you include an directory (e.g #include \"dir\" ) it will search for file in that directory named same as directory itself, e.g dir directory will search for dir/dir.gof file and that is being included, that simplifies layout of directory tree of libraries","title":"Module include"},{"location":"advanced/preprocessor/#searching-strategy","text":"At start of search, same file or an directory (e.g directory include file) will be searched in current working file directory parent, e.g if you include something from stdlib and it include something it first looks at its own directory, not your main one At next, if file is not found, it will search from directory where you main file is located And if file is not found there also, it will search against all include search directory (e.g -isd CLI flag) Overview: 1. Parent of an current file (not main) 2. Parent of an main file 3. Include search directories","title":"Searching strategy"},{"location":"advanced/preprocessor/#macro-definitions","text":"To define an macro you can use #define preprocessor directive (and #undef ) correspondingly #define MACRO 2 // macro containing an token 2 after that you are allowed to inject that macro inside your code MACRO MACRO + // 4 (2 2 +)","title":"Macro definitions"},{"location":"advanced/preprocessor/#propagation-via-cli","text":"You can use -D flag to define an macro from CLI which is useful for something like debug flags -Ddebug=1 (define an macro debug with value 1)","title":"Propagation via CLI"},{"location":"advanced/preprocessor/#definition-checking-at-preprocessor-stage","text":"You can use #ifdef , #ifndef and #endif for checking definition of an macro #ifdef DEBUG // only be compiled if DEBUG macro is present #endif","title":"Definition checking at preprocessor stage"},{"location":"advanced/preprocessor/#toolchain-propagated-macros-and-target-specific-macros","text":"By default Gofra provides two macros: OS_{NAME} and ARCH_{NAME} For example while compiling to Darwin on ARM64 there will be 2 macros available -> OS_DARWIN and ARCH_ARM64","title":"Toolchain propagated macros and target specific macros"},{"location":"advanced/toolchain-architecture/","text":"Toolchain (Compiler) architecture This page explains internals of compiler (toolchain) and is useful for development, continue reading if you need this Core modules Toolchain consists of widely used components: Lexer, Parser, Codegen but also contains Preprocessor, Optimizer, Typechecker and also relatable to notice is Linker, Assembler and CLI Toolchain CLI goal flow CLI -> Lexer -> Preprocessor -> Parser -> Typechecker -> Optimizer -> Codegen -> Assembler -> Linker Structure of default Code-generators By default all architectures emits assembly-code (e.g almost nearly machine code) that is requires to be assembler into binary machine code via Assembler Structure of typechecker As parser produce an HIR and does barely perform type checking, there is an Typechecker module which is responsible for checking that types are compatible within operations (e.g plus or function call)","title":"Toolchain (Compiler) architecture"},{"location":"advanced/toolchain-architecture/#toolchain-compiler-architecture","text":"This page explains internals of compiler (toolchain) and is useful for development, continue reading if you need this","title":"Toolchain (Compiler) architecture"},{"location":"advanced/toolchain-architecture/#core-modules","text":"Toolchain consists of widely used components: Lexer, Parser, Codegen but also contains Preprocessor, Optimizer, Typechecker and also relatable to notice is Linker, Assembler and CLI","title":"Core modules"},{"location":"advanced/toolchain-architecture/#toolchain-cli-goal-flow","text":"CLI -> Lexer -> Preprocessor -> Parser -> Typechecker -> Optimizer -> Codegen -> Assembler -> Linker","title":"Toolchain CLI goal flow"},{"location":"advanced/toolchain-architecture/#structure-of-default-code-generators","text":"By default all architectures emits assembly-code (e.g almost nearly machine code) that is requires to be assembler into binary machine code via Assembler","title":"Structure of default Code-generators"},{"location":"advanced/toolchain-architecture/#structure-of-typechecker","text":"As parser produce an HIR and does barely perform type checking, there is an Typechecker module which is responsible for checking that types are compatible within operations (e.g plus or function call)","title":"Structure of typechecker"},{"location":"advanced/type-definition/","text":"Type definition Gofra has type keyword that allows define types (Generic types, type aliases) Type alias(ing) Type definition allows to define type alias to arbitrary data type type Alias = int var x Alias = 5; // same as int Generics Type definitions is also used to define an generic type type Generic{T} = T Read more at Generic types page","title":"Type definition"},{"location":"advanced/type-definition/#type-definition","text":"Gofra has type keyword that allows define types (Generic types, type aliases)","title":"Type definition"},{"location":"advanced/type-definition/#type-aliasing","text":"Type definition allows to define type alias to arbitrary data type type Alias = int var x Alias = 5; // same as int","title":"Type alias(ing)"},{"location":"advanced/type-definition/#generics","text":"Type definitions is also used to define an generic type type Generic{T} = T Read more at Generic types page","title":"Generics"},{"location":"advanced/typechecker/","text":"Type checker Type checking is always performed by default at compile-time (unless -nt or --no-typecheck flag is passed) It validates all stack usages and function calls Implementation Type checker is implemented as type-stack machine which behaves like stack based machine but operates on types So for example 2 will resolve into typestack = [INT] Typechecker will perform type safety validation even for unused functions (expect function calls, as there is no calls for unused functions) Unless you apply DCE optimization at compile-time (as it performed before type checker stage) Type checker will go into each function and validate its return type and stack usage and emit an error if something weird is found When typechecker found an call inside current function, it will consume desired parameters as arguments from type stack and push return type unless it not void type Type comparison Typechecker always uses strategy called strict-same-type which means types must be always same and no inference / type lowering is possible (you must always statically type cast for fixing errors) Possible next update will introduce something new, allowing to use implicit-byte-size strategy or any type lowering automatically at typechecker stage Is type checker affects runtime / generate code? Type checker is meant to only type-safety feature, so no generated code is affected by typechecker, even type casts are static ones and only applied to type checker, not anything else","title":"Type checker"},{"location":"advanced/typechecker/#type-checker","text":"Type checking is always performed by default at compile-time (unless -nt or --no-typecheck flag is passed) It validates all stack usages and function calls","title":"Type checker"},{"location":"advanced/typechecker/#implementation","text":"Type checker is implemented as type-stack machine which behaves like stack based machine but operates on types So for example 2 will resolve into typestack = [INT] Typechecker will perform type safety validation even for unused functions (expect function calls, as there is no calls for unused functions) Unless you apply DCE optimization at compile-time (as it performed before type checker stage) Type checker will go into each function and validate its return type and stack usage and emit an error if something weird is found When typechecker found an call inside current function, it will consume desired parameters as arguments from type stack and push return type unless it not void type","title":"Implementation"},{"location":"advanced/typechecker/#type-comparison","text":"Typechecker always uses strategy called strict-same-type which means types must be always same and no inference / type lowering is possible (you must always statically type cast for fixing errors) Possible next update will introduce something new, allowing to use implicit-byte-size strategy or any type lowering automatically at typechecker stage","title":"Type comparison"},{"location":"advanced/typechecker/#is-type-checker-affects-runtime-generate-code","text":"Type checker is meant to only type-safety feature, so no generated code is affected by typechecker, even type casts are static ones and only applied to type checker, not anything else","title":"Is type checker affects runtime / generate code?"},{"location":"advanced/wasm/","text":"WebAssembly (WASM) This page covers essentials and underlying tech required for working with Gofra as compiler for WASM target. What is WASM? WASM is an alternative for writing web-based (browser) applications, it offers near-native performance, and compilation from high-level languages like Gofra to it machine instructions Any file with .wasm extension is machine instructions code that must be loaded via appropriate environment (Node.js/Browser) Any file with .wat extension is assembly textual representation of WASM Compiling \"Hello, World!\" to WASM To compile something simple like \"Hello, World!\" you need to specify target like --target wasm / -t wasm As WASM isn't executable on its own it requires appropriate environment, so we specify -of object to emit .wasm file (WASM target does not allows to emit default -of executable target) After these steps we have command like gofra ./hello_world.gof -t wasm -of object which emits hello_world.wasm to us. How to execute WASM artifact To execute almost any WASM artifact (e.g .wasm file) you need loader with environment, one of those is Node.JS , loader for it located in /wasm/node_example_loader.js , same logic and environment is usable for browsers with tweaking how loader loads wasm file and from which script (e.g .html ) For more complex examples with environment look into /wasm/example_wasm_raylib_layer_loader.html","title":"WebAssembly (WASM)"},{"location":"advanced/wasm/#webassembly-wasm","text":"This page covers essentials and underlying tech required for working with Gofra as compiler for WASM target.","title":"WebAssembly (WASM)"},{"location":"advanced/wasm/#what-is-wasm","text":"WASM is an alternative for writing web-based (browser) applications, it offers near-native performance, and compilation from high-level languages like Gofra to it machine instructions Any file with .wasm extension is machine instructions code that must be loaded via appropriate environment (Node.js/Browser) Any file with .wat extension is assembly textual representation of WASM","title":"What is WASM?"},{"location":"advanced/wasm/#compiling-hello-world-to-wasm","text":"To compile something simple like \"Hello, World!\" you need to specify target like --target wasm / -t wasm As WASM isn't executable on its own it requires appropriate environment, so we specify -of object to emit .wasm file (WASM target does not allows to emit default -of executable target) After these steps we have command like gofra ./hello_world.gof -t wasm -of object which emits hello_world.wasm to us.","title":"Compiling \"Hello, World!\" to WASM"},{"location":"advanced/wasm/#how-to-execute-wasm-artifact","text":"To execute almost any WASM artifact (e.g .wasm file) you need loader with environment, one of those is Node.JS , loader for it located in /wasm/node_example_loader.js , same logic and environment is usable for browsers with tweaking how loader loads wasm file and from which script (e.g .html ) For more complex examples with environment look into /wasm/example_wasm_raylib_layer_loader.html","title":"How to execute WASM artifact"},{"location":"datatypes/array/","text":"Array data type In Gofra array is a composite data type that represents a pointer to a contiguous segment of memory storing a fixed number of elements of the same specified type. Unlike dynamic collections, arrays in Gofra have a predetermined size that cannot be changed after declaration. Layout In memory, as array being contiguous blob of memory, it corresponding value points at first element in memory shifting that pointer // [element0element1element2] // ^ ^ // array ptr | // ptr+sizeof So accessing memory at array pointer will lead to reading its first element While second element is at pointer + size of array element For int8 which size is 8 bytes, var array int[3] according to image above has memory layout like array -> pointer to an first element array + 8 -> pointer to an second element array + 16 -> pointer to an third element For convenient usage of layout, see Accessing array element section Syntax Array type is defined as element type followed by square brackets int[32] // Array of 32 integer elements int[] // Incomplete array definition, for type parameters Initialization Arrays currently does not have constructors, and by default all arrays are zero-initialized You has to manually initialize array with memory write instructions Incomplete array type definition As you see before, there is possibility to define an incomplete type for array (e.g int[] ) this has no effect while used as variable or field type as leading to generation of an empty blob segment (zero elements by default, meaning size of array is zero, no way to generate that blob or it is inaccessible) This incomplete array types is used as function parameters, as mark that array has any arbitrary size while passed to desired function: func void incomplete_array[int[]] ... end This function can be called with array of any size like int[32] or int[1] but any other type is prohibited Mostly, useful for accepting array of character as strings, as size is useless mostly for these function (e.g to calculate string size) Accessing array element As documented in Layout section, you must already know how does array layouts in memory, but using pointer arithmetics is weird as you can access direct array indices at runtime via var array int[32] array[0] // pointer to an first element, same as `array` array[3] // pointer to third element, same as `array + sizeof(int) * 3` or `array + 8 * 3` which is shift pointer by 24 You also can use variable identifier to get array index by value of that variable Pointer arithmetics equivalent var array int[32] array 8 0 * + // pointer to first element array 8 3 * + // pointer to third element OOB (Out-Of-Bounds) Gofra performs compile-time bounds checking where possible: var array int[5] array[5] // Compilation error: OOB for array access","title":"Array data type"},{"location":"datatypes/array/#array-data-type","text":"In Gofra array is a composite data type that represents a pointer to a contiguous segment of memory storing a fixed number of elements of the same specified type. Unlike dynamic collections, arrays in Gofra have a predetermined size that cannot be changed after declaration.","title":"Array data type"},{"location":"datatypes/array/#layout","text":"In memory, as array being contiguous blob of memory, it corresponding value points at first element in memory shifting that pointer // [element0element1element2] // ^ ^ // array ptr | // ptr+sizeof So accessing memory at array pointer will lead to reading its first element While second element is at pointer + size of array element For int8 which size is 8 bytes, var array int[3] according to image above has memory layout like array -> pointer to an first element array + 8 -> pointer to an second element array + 16 -> pointer to an third element For convenient usage of layout, see Accessing array element section","title":"Layout"},{"location":"datatypes/array/#syntax","text":"Array type is defined as element type followed by square brackets int[32] // Array of 32 integer elements int[] // Incomplete array definition, for type parameters","title":"Syntax"},{"location":"datatypes/array/#initialization","text":"Arrays currently does not have constructors, and by default all arrays are zero-initialized You has to manually initialize array with memory write instructions","title":"Initialization"},{"location":"datatypes/array/#incomplete-array-type-definition","text":"As you see before, there is possibility to define an incomplete type for array (e.g int[] ) this has no effect while used as variable or field type as leading to generation of an empty blob segment (zero elements by default, meaning size of array is zero, no way to generate that blob or it is inaccessible) This incomplete array types is used as function parameters, as mark that array has any arbitrary size while passed to desired function: func void incomplete_array[int[]] ... end This function can be called with array of any size like int[32] or int[1] but any other type is prohibited Mostly, useful for accepting array of character as strings, as size is useless mostly for these function (e.g to calculate string size)","title":"Incomplete array type definition"},{"location":"datatypes/array/#accessing-array-element","text":"As documented in Layout section, you must already know how does array layouts in memory, but using pointer arithmetics is weird as you can access direct array indices at runtime via var array int[32] array[0] // pointer to an first element, same as `array` array[3] // pointer to third element, same as `array + sizeof(int) * 3` or `array + 8 * 3` which is shift pointer by 24 You also can use variable identifier to get array index by value of that variable","title":"Accessing array element"},{"location":"datatypes/array/#pointer-arithmetics-equivalent","text":"var array int[32] array 8 0 * + // pointer to first element array 8 3 * + // pointer to third element","title":"Pointer arithmetics equivalent"},{"location":"datatypes/array/#oob-out-of-bounds","text":"Gofra performs compile-time bounds checking where possible: var array int[5] array[5] // Compilation error: OOB for array access","title":"OOB (Out-Of-Bounds)"},{"location":"datatypes/string/","text":"String data type Strings in Gofra are represented via Fat Pointers (Or also called String View and String Slice ) Using string data type: var str *string = \"text\" // Type may be omitted \"another text\" // Pushes *string on stack str.data // Push underlying *boxed* pointer to CStr (*char[]) str.len // Size (bytes) of the string (character length in UTF-8 as single byte for character) Internally, string structure type is available for any compiled program and defined like so: type struct string data *char[] len int end That structure takes 16 bytes (8 bytes ptr, 8 bytes len) Strings defined internally in source code located in static data segment (must has Read-Only memory protection)","title":"String data type"},{"location":"datatypes/string/#string-data-type","text":"Strings in Gofra are represented via Fat Pointers (Or also called String View and String Slice ) Using string data type: var str *string = \"text\" // Type may be omitted \"another text\" // Pushes *string on stack str.data // Push underlying *boxed* pointer to CStr (*char[]) str.len // Size (bytes) of the string (character length in UTF-8 as single byte for character) Internally, string structure type is available for any compiled program and defined like so: type struct string data *char[] len int end That structure takes 16 bytes (8 bytes ptr, 8 bytes len) Strings defined internally in source code located in static data segment (must has Read-Only memory protection)","title":"String data type"},{"location":"tutorial/","text":"Usage and tutorials IDE and Editor support Control flow Memory management Stack management operators Bitwise operators Variables Structures Type casts Arrays Strings","title":"Tutorial"},{"location":"tutorial/#usage-and-tutorials","text":"","title":"Usage and tutorials"},{"location":"tutorial/#ide-and-editor-support","text":"","title":"IDE and Editor support"},{"location":"tutorial/#control-flow","text":"","title":"Control flow"},{"location":"tutorial/#memory-management","text":"","title":"Memory management"},{"location":"tutorial/#stack-management-operators","text":"","title":"Stack management operators"},{"location":"tutorial/#bitwise-operators","text":"","title":"Bitwise operators"},{"location":"tutorial/#variables","text":"","title":"Variables"},{"location":"tutorial/#structures","text":"","title":"Structures"},{"location":"tutorial/#type-casts","text":"","title":"Type casts"},{"location":"tutorial/#arrays","text":"","title":"Arrays"},{"location":"tutorial/#strings","text":"","title":"Strings"},{"location":"tutorial/bitwise-operators/","text":"Bitwise operators Shift left and right (<<, >>) Logical shift right and left Example 2 3 << // logical shift 2 by 2 bits to the left 2 3 >> // logical shift 2 by 3 bits to the right AND (&) 2 3 & // 0b10 & 0b11 -> 0b10 -> 2 XOR (^) 2 3 ^ // 0b10 ^0b11 -> 0b01 -> 1","title":"Bitwise operators"},{"location":"tutorial/bitwise-operators/#bitwise-operators","text":"","title":"Bitwise operators"},{"location":"tutorial/bitwise-operators/#shift-left-and-right","text":"Logical shift right and left Example 2 3 << // logical shift 2 by 2 bits to the left 2 3 >> // logical shift 2 by 3 bits to the right","title":"Shift left and right (&lt;&lt;, &gt;&gt;)"},{"location":"tutorial/bitwise-operators/#and","text":"2 3 & // 0b10 & 0b11 -> 0b10 -> 2","title":"AND (&amp;)"},{"location":"tutorial/bitwise-operators/#xor","text":"2 3 ^ // 0b10 ^0b11 -> 0b01 -> 1","title":"XOR (^)"},{"location":"tutorial/control-flow/","text":"Control Flow Constructs Gofra provides essential control flow constructs for conditional execution and looping. if Statement The if statement evaluates a boolean condition and executes the block if the condition is non-zero. Syntax <condition> if // code to execute if condition is true end Example // This block will NOT execute 0 1 == if \"This will not be printed\" print end // This block WILL execute 1 1 == if \"This will be printed\" print end // Using variables var is_valid bool &is_valid true !< is_valid if \"Valid state\" print end while Statement The while loop repeatedly executes a block of code as long as the condition remains non-zero. The loop continues until the condition evaluates to false (zero). Syntax while <condition> do // code to execute repeatedly end Example var counter int = 0; // Initialize counter to 0 while counter 10 < // condition do \"Hello! Iteration: \" print counter print_integer // Print current counter value \"\\n\" print &counter copy ?> 1 + !< // Increment counter end Control flow pattern while \u2192 (condition check) \u2192 do \u2192 end \u2192 while (loop back) \u2502 \u2193 (condition false) (exit loop) for Statement The for loop is under the hood is same/using while construction but adds syntactical sugar for auto-constraints and counters (iterator, iterable) At entering the loop, iterator variable will be set to low threshold of range Range is exclusive (not inclusive) Example for i in 0..10 do // i will be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] end for i in 10..0 do // i will be [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] end var x = 5; for i in 0..x do // variables is allowed only on RHS for now, TODO // Step always will be 1, reversed iterations is not possible! // i will be [0, 1, 2, 3, 4] end var xs = [5, 6, 7]; for i in 0..xs do // iterate up to size of xs (index iterator) // i will be [0, 1, 2] end for x in xs do // iterate iterables // x will be [*5, *6, *7] // Iterates over pointer as does not have iterator in simple form - shifts array pointer end Comparison to while HIR syntactical sugar Something like this: for i in 0..10 do end Is being translated by compiler frontend into something like var i int = 0; while i 10 < do // For variable range 10 is replaced ith loading variable, for reversed range, will be `>` // body of for &i i 1 + !< // Decrement if reversed end","title":"Control Flow Constructs"},{"location":"tutorial/control-flow/#control-flow-constructs","text":"Gofra provides essential control flow constructs for conditional execution and looping.","title":"Control Flow Constructs"},{"location":"tutorial/control-flow/#if-statement","text":"The if statement evaluates a boolean condition and executes the block if the condition is non-zero.","title":"if Statement"},{"location":"tutorial/control-flow/#syntax","text":"<condition> if // code to execute if condition is true end","title":"Syntax"},{"location":"tutorial/control-flow/#example","text":"// This block will NOT execute 0 1 == if \"This will not be printed\" print end // This block WILL execute 1 1 == if \"This will be printed\" print end // Using variables var is_valid bool &is_valid true !< is_valid if \"Valid state\" print end","title":"Example"},{"location":"tutorial/control-flow/#while-statement","text":"The while loop repeatedly executes a block of code as long as the condition remains non-zero. The loop continues until the condition evaluates to false (zero).","title":"while Statement"},{"location":"tutorial/control-flow/#syntax_1","text":"while <condition> do // code to execute repeatedly end","title":"Syntax"},{"location":"tutorial/control-flow/#example_1","text":"var counter int = 0; // Initialize counter to 0 while counter 10 < // condition do \"Hello! Iteration: \" print counter print_integer // Print current counter value \"\\n\" print &counter copy ?> 1 + !< // Increment counter end","title":"Example"},{"location":"tutorial/control-flow/#control-flow-pattern","text":"while \u2192 (condition check) \u2192 do \u2192 end \u2192 while (loop back) \u2502 \u2193 (condition false) (exit loop)","title":"Control flow pattern"},{"location":"tutorial/control-flow/#for-statement","text":"The for loop is under the hood is same/using while construction but adds syntactical sugar for auto-constraints and counters (iterator, iterable) At entering the loop, iterator variable will be set to low threshold of range Range is exclusive (not inclusive)","title":"for Statement"},{"location":"tutorial/control-flow/#example_2","text":"for i in 0..10 do // i will be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] end for i in 10..0 do // i will be [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] end var x = 5; for i in 0..x do // variables is allowed only on RHS for now, TODO // Step always will be 1, reversed iterations is not possible! // i will be [0, 1, 2, 3, 4] end var xs = [5, 6, 7]; for i in 0..xs do // iterate up to size of xs (index iterator) // i will be [0, 1, 2] end for x in xs do // iterate iterables // x will be [*5, *6, *7] // Iterates over pointer as does not have iterator in simple form - shifts array pointer end","title":"Example"},{"location":"tutorial/control-flow/#comparison-to-while-hir-syntactical-sugar","text":"Something like this: for i in 0..10 do end Is being translated by compiler frontend into something like var i int = 0; while i 10 < do // For variable range 10 is replaced ith loading variable, for reversed range, will be `>` // body of for &i i 1 + !< // Decrement if reversed end","title":"Comparison to while HIR syntactical sugar"},{"location":"tutorial/memory/","text":"Memory management Memory management is a fundamental aspect of programming. Gofra provides direct memory access operations for loading and storing data. Critical notice Currently, in gofra load and store operations works with always 8-bytes data, so this will cause some overwriting of memory layout, consider that while using critical to memory operations Memory operations Store into memory Stores a value at a specified memory address. Mnemonic: a b -> _ _ Intrinsic: !< Consumes two values from the stack: [address, value] Stores value at memory location address Both values are removed from the stack Syntax <address> <value> !< Examples // Store to a variable var name int &name 1 !< // Store 1 into name // Store to calculated address var array int[10] &array 0 + 42 !< // Store 42 at array[0] &array 8 + 99 !< // Store 99 at array[8] (if int is 4 bytes) Load from memory Stores a value at a specified memory address. Mnemonic: a -> b Intrinsic: ?> Consumes one value from the stack: [address] Loads the value from memory location address Pushes the loaded value onto the stack Syntax <address> ?> To push variable onto stack: <variable> Examples // Load from a variable var name int &name 1 !< // Store 1 into name &name ?> // Load value from name (pushes 1 onto stack) // or name print_integer // Prints 1 // Load from array element var numbers int[3] &numbers 0 + 10 !< // numbers[0] = 10 &numbers 8 + 20 !< // numbers[1] = 20 (assuming 8-byte integers) &numbers 0 + ?> print // Load and print numbers[0] Memory Size Considerations Pointer Width : Determined by CPU architecture (typically 32-bit or 64-bit) Word Size : Architecture-dependent, affects natural memory alignment Type Sizes : Different data types occupy different amounts of memory Type size reference var b char // 1 byte var i int // 4 or 8 bytes (architecture-dependent) var p *int // 4 or 8 bytes (pointer width)","title":"Memory management"},{"location":"tutorial/memory/#memory-management","text":"Memory management is a fundamental aspect of programming. Gofra provides direct memory access operations for loading and storing data.","title":"Memory management"},{"location":"tutorial/memory/#critical-notice","text":"Currently, in gofra load and store operations works with always 8-bytes data, so this will cause some overwriting of memory layout, consider that while using critical to memory operations","title":"Critical notice"},{"location":"tutorial/memory/#memory-operations","text":"","title":"Memory operations"},{"location":"tutorial/memory/#store-into-memory","text":"Stores a value at a specified memory address. Mnemonic: a b -> _ _ Intrinsic: !< Consumes two values from the stack: [address, value] Stores value at memory location address Both values are removed from the stack","title":"Store into memory"},{"location":"tutorial/memory/#syntax","text":"<address> <value> !<","title":"Syntax"},{"location":"tutorial/memory/#examples","text":"// Store to a variable var name int &name 1 !< // Store 1 into name // Store to calculated address var array int[10] &array 0 + 42 !< // Store 42 at array[0] &array 8 + 99 !< // Store 99 at array[8] (if int is 4 bytes)","title":"Examples"},{"location":"tutorial/memory/#load-from-memory","text":"Stores a value at a specified memory address. Mnemonic: a -> b Intrinsic: ?> Consumes one value from the stack: [address] Loads the value from memory location address Pushes the loaded value onto the stack","title":"Load from memory"},{"location":"tutorial/memory/#syntax_1","text":"<address> ?> To push variable onto stack: <variable>","title":"Syntax"},{"location":"tutorial/memory/#examples_1","text":"// Load from a variable var name int &name 1 !< // Store 1 into name &name ?> // Load value from name (pushes 1 onto stack) // or name print_integer // Prints 1 // Load from array element var numbers int[3] &numbers 0 + 10 !< // numbers[0] = 10 &numbers 8 + 20 !< // numbers[1] = 20 (assuming 8-byte integers) &numbers 0 + ?> print // Load and print numbers[0]","title":"Examples"},{"location":"tutorial/memory/#memory-size-considerations","text":"Pointer Width : Determined by CPU architecture (typically 32-bit or 64-bit) Word Size : Architecture-dependent, affects natural memory alignment Type Sizes : Different data types occupy different amounts of memory","title":"Memory Size Considerations"},{"location":"tutorial/memory/#type-size-reference","text":"var b char // 1 byte var i int // 4 or 8 bytes (architecture-dependent) var p *int // 4 or 8 bytes (pointer width)","title":"Type size reference"},{"location":"tutorial/stack-management-operators/","text":"Stack management operators For managing an stack you must have some less-or-more complex commands for example like swap or rot , language supports some of them. SWAP Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 3 2 swap - // -1 DROP Mnemonics: a -> _ Drops element from stack Example: 2 2 100 drop + // 4, and empty stack COPY Mnemonics: a -> a a Copies element from stack Example: 2 copy // 2 2 on stack Tips and Tricks swap is useful when initializing local variables by function arguments values. For example: gofra func int str2int[ *char[], int ] do var len int; &len swap !< var ptr *char[]; &ptr swap !< ... end In this example, the len variable is initialized by the int value from the arguments and the ptr variable is initialized by the *char[] value from the arguments. copy is useful when increasing or decreasing some value. For example: ``` var number int = 0; &number copy ?> 10 + !< // number = number + 10 ```","title":"Stack management operators"},{"location":"tutorial/stack-management-operators/#stack-management-operators","text":"For managing an stack you must have some less-or-more complex commands for example like swap or rot , language supports some of them.","title":"Stack management operators"},{"location":"tutorial/stack-management-operators/#swap","text":"Mnemonics: a b -> b a Swaps two arguments from stack, for example for reaching second argument Example 3 2 - // 1 3 2 swap - // -1","title":"SWAP"},{"location":"tutorial/stack-management-operators/#drop","text":"Mnemonics: a -> _ Drops element from stack Example: 2 2 100 drop + // 4, and empty stack","title":"DROP"},{"location":"tutorial/stack-management-operators/#copy","text":"Mnemonics: a -> a a Copies element from stack Example: 2 copy // 2 2 on stack","title":"COPY"},{"location":"tutorial/stack-management-operators/#tips-and-tricks","text":"swap is useful when initializing local variables by function arguments values. For example: gofra func int str2int[ *char[], int ] do var len int; &len swap !< var ptr *char[]; &ptr swap !< ... end In this example, the len variable is initialized by the int value from the arguments and the ptr variable is initialized by the *char[] value from the arguments. copy is useful when increasing or decreasing some value. For example: ``` var number int = 0; &number copy ?> 10 + !< // number = number + 10 ```","title":"Tips and Tricks"},{"location":"tutorial/structures/","text":"Structures Structs currently is an something like type-definition with proper type checking and field accessors (auto-shift) Defining an structure type struct name field type ... end For example defining an person struct struct Person age int name *char[] end Accessing an structure field var stepan Person // initialize variable of type Person stepan.age // will push an pointer to an `age` field so you can write / read from it Forward reference and self-reference Forward reference of structures as children field is allowed: struct X id int child X end // 16 bytes // This will define X as (8 byte int + 8 byte X (int)) Alignment on CPUs and packed layout By default, all structures being aligned in memory according to max alignment of its own fields, e.g if biggest field type is int (8 bytes) then alignment for whole structure must be same amount of bytes This can be overridden by specifying packed attribute for structure, which means do not apply any alignment, place all fields as-is linearly in memory struct bad_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, 24 bytes struct packed packed_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Packed, 10 bytes Packed (tight memory layout) |-------------| |a| b |c|| => 10 bytes |-------------| Aligned (thin memory layout) |-------------------------------------------| |a|...padding...| b |...padding...|c| => 24 bytes |-------------------------------------------| Padding is from both sides to properly align *int* (8 bytes) field access on CPU Reordering Reordering is a process when for performance reasons fields of structure being re-ordered to solve alignment issues (redundant padding on structure memory layout) By default, structures does not apply reordering, this behavior can be overridden by specifying reorder attribute for structure. struct bad_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, 24 bytes struct reorder reordered_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, reordered 16 bytes // Order was transformed into [b, a, c] (int, char, char) re-using padding from int to char offset_of offset_of pushes byte offset for specified field for given structure (concrete ones) offset_of {STRUCTURE_TYPE} {FIELD_NAME} It takes into account any alignment / reordering that is possible, and offset will be always same, as those whose will be used inside low-level machine code / ABI calls struct Foo // No special alignment, simple struct a int b int end offset_of Foo a // 0 offset_of Foo b // 8 align_of align_of pushes alignment for specified type align_of {TYPE} It takes into account any alignment / reordering that is possible, and offset will be always same, as those whose will be used inside low-level machine code / ABI calls struct Foo // No special alignment, simple struct a int b int end align_of Foo // 8 (max is int, 8 bytes) align_of int // 8 align_of char // 1 align_of int[32] // 8, alignment of int Generic structure types // Define generic struct with type param T struct Generic{T} field_a T field_b T field_c int end var x Generic{T = int} // Variable with concrete type","title":"Structures"},{"location":"tutorial/structures/#structures","text":"Structs currently is an something like type-definition with proper type checking and field accessors (auto-shift)","title":"Structures"},{"location":"tutorial/structures/#defining-an-structure-type","text":"struct name field type ... end For example defining an person struct struct Person age int name *char[] end","title":"Defining an structure type"},{"location":"tutorial/structures/#accessing-an-structure-field","text":"var stepan Person // initialize variable of type Person stepan.age // will push an pointer to an `age` field so you can write / read from it","title":"Accessing an structure field"},{"location":"tutorial/structures/#forward-reference-and-self-reference","text":"Forward reference of structures as children field is allowed: struct X id int child X end // 16 bytes // This will define X as (8 byte int + 8 byte X (int))","title":"Forward reference and self-reference"},{"location":"tutorial/structures/#alignment-on-cpus-and-packed-layout","text":"By default, all structures being aligned in memory according to max alignment of its own fields, e.g if biggest field type is int (8 bytes) then alignment for whole structure must be same amount of bytes This can be overridden by specifying packed attribute for structure, which means do not apply any alignment, place all fields as-is linearly in memory struct bad_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, 24 bytes struct packed packed_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Packed, 10 bytes Packed (tight memory layout) |-------------| |a| b |c|| => 10 bytes |-------------| Aligned (thin memory layout) |-------------------------------------------| |a|...padding...| b |...padding...|c| => 24 bytes |-------------------------------------------| Padding is from both sides to properly align *int* (8 bytes) field access on CPU","title":"Alignment on CPUs and packed layout"},{"location":"tutorial/structures/#reordering","text":"Reordering is a process when for performance reasons fields of structure being re-ordered to solve alignment issues (redundant padding on structure memory layout) By default, structures does not apply reordering, this behavior can be overridden by specifying reorder attribute for structure. struct bad_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, 24 bytes struct reorder reordered_layout a char // 1 byte b int // 8 byte c char // 1 byte end // Unpacked, reordered 16 bytes // Order was transformed into [b, a, c] (int, char, char) re-using padding from int to char","title":"Reordering"},{"location":"tutorial/structures/#offset_of","text":"offset_of pushes byte offset for specified field for given structure (concrete ones) offset_of {STRUCTURE_TYPE} {FIELD_NAME} It takes into account any alignment / reordering that is possible, and offset will be always same, as those whose will be used inside low-level machine code / ABI calls struct Foo // No special alignment, simple struct a int b int end offset_of Foo a // 0 offset_of Foo b // 8","title":"offset_of"},{"location":"tutorial/structures/#align_of","text":"align_of pushes alignment for specified type align_of {TYPE} It takes into account any alignment / reordering that is possible, and offset will be always same, as those whose will be used inside low-level machine code / ABI calls struct Foo // No special alignment, simple struct a int b int end align_of Foo // 8 (max is int, 8 bytes) align_of int // 8 align_of char // 1 align_of int[32] // 8, alignment of int","title":"align_of"},{"location":"tutorial/structures/#generic-structure-types","text":"// Define generic struct with type param T struct Generic{T} field_a T field_b T field_c int end var x Generic{T = int} // Variable with concrete type","title":"Generic structure types"},{"location":"tutorial/typecasts/","text":"Type casting There is always situations when you need to cast one type to another to silence errors from typechecker as it quite dumb and may stay on your way For that you have type casting feature (static type casts) only Static type cast Static type cast is an form of casting to an desired type which has no effect on runtime, only compile-time type checking only to statically cast to an type you may do following var a char a typecast int 2 * // by default multiplying an char is not possible typecasts is always in form of: typecast {type_definition_from_scope} You may write any arbitrary and composite / complex types inside typecast (e.g cast to an pointer to an struct)","title":"Type casting"},{"location":"tutorial/typecasts/#type-casting","text":"There is always situations when you need to cast one type to another to silence errors from typechecker as it quite dumb and may stay on your way For that you have type casting feature (static type casts) only","title":"Type casting"},{"location":"tutorial/typecasts/#static-type-cast","text":"Static type cast is an form of casting to an desired type which has no effect on runtime, only compile-time type checking only to statically cast to an type you may do following var a char a typecast int 2 * // by default multiplying an char is not possible typecasts is always in form of: typecast {type_definition_from_scope} You may write any arbitrary and composite / complex types inside typecast (e.g cast to an pointer to an struct)","title":"Static type cast"},{"location":"tutorial/variables/","text":"Variables That page is being written, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions) Variable definitions Variable definitions looks like that: // Primitive type var {name} [type] // Composite type var array {type}[{size_in_elements}] var ptr *{type} var complex **int[32] // pointer to an pointer containing array of integers It must start with var then name and type Initializers var x int = 10; var x char = 'a'; // or 97 var x *string = \"Hello, World\"; var x int[3] = [1, 2, 3] // Has size inference and validation, rest undefined is always treated as zero initialized (even for stack) Type inference and auto types If defining an variable without an type and it has proper initializer, type may be omitted: var x = 5; // int var x = \"test\" // *string var x = [1, 2, 3] // int[3] var error = [] // Error: is it int[] or whatever else possible? Requires type explicitly Type casting at initializer For few simple types auto type casting (e.g reinterpret cast) is allowed: var x bool = 1; // Reinterpret(*) bytes as bool and allow proper type var x char = 97 // 'a' Constants Variable with initializer known at compile time may become const by using this syntax: const x = 5; const var = 10; Constants are prohibited to obtain their memory address (restricted modifications) and allows optimizer to apply inlining/unwind and DCE on usage Primitive and composite types: differences Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of caricature (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} - Structure with set of {primitive|complex} type inside Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type Local and static (global) variable location: differences Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reset // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local int end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout Local variables: alignment on CPUs Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Variables"},{"location":"tutorial/variables/#variables","text":"That page is being written, and only may be used as quick-overview Variables is an container for your arbitrary data (within variable type size), they can be static ( global ) and local (to functions)","title":"Variables"},{"location":"tutorial/variables/#variable-definitions","text":"Variable definitions looks like that: // Primitive type var {name} [type] // Composite type var array {type}[{size_in_elements}] var ptr *{type} var complex **int[32] // pointer to an pointer containing array of integers It must start with var then name and type","title":"Variable definitions"},{"location":"tutorial/variables/#initializers","text":"var x int = 10; var x char = 'a'; // or 97 var x *string = \"Hello, World\"; var x int[3] = [1, 2, 3] // Has size inference and validation, rest undefined is always treated as zero initialized (even for stack)","title":"Initializers"},{"location":"tutorial/variables/#type-inference-and-auto-types","text":"If defining an variable without an type and it has proper initializer, type may be omitted: var x = 5; // int var x = \"test\" // *string var x = [1, 2, 3] // int[3] var error = [] // Error: is it int[] or whatever else possible? Requires type explicitly","title":"Type inference and auto types"},{"location":"tutorial/variables/#type-casting-at-initializer","text":"For few simple types auto type casting (e.g reinterpret cast) is allowed: var x bool = 1; // Reinterpret(*) bytes as bool and allow proper type var x char = 97 // 'a'","title":"Type casting at initializer"},{"location":"tutorial/variables/#constants","text":"Variable with initializer known at compile time may become const by using this syntax: const x = 5; const var = 10; Constants are prohibited to obtain their memory address (restricted modifications) and allows optimizer to apply inlining/unwind and DCE on usage","title":"Constants"},{"location":"tutorial/variables/#primitive-and-composite-types-differences","text":"Primitive type is such type that only contains an size of memory blob and nothing more inside Composite type is such type which contains another type inside (may be primitive or complex) that it refers to (e.g array of elements contains primitive type of an single element and pointer is containing type of memory it refers to (pointer to an integer is an complex pointer type referencing integer and string is in general an complex type as it refers to array of caricature (contiguous memory blob) as another complex type)) Primitive types: - int - char - byte Composite type - Array of {primitive|complex type} - Pointer to {primitive|complex type} - Structure with set of {primitive|complex} type inside Composite types may contain another complex types so pointer to array of pointers to integer is an 2-level complex type","title":"Primitive and composite types: differences"},{"location":"tutorial/variables/#local-and-static-global-variable-location-differences","text":"Static variable is such variable that is defined outside of an function (e.g at top level) while being compiled it located in static memory segment at runtime (e.g data / bss) section, it always initialized and persist it value between function calls (as anyone may modify that variable) Local variable is such variable that is define inside an function, while being compiled it will be translated into local region on an stack, so with each function call with that variable it will be reset // Global variable // located in static binary segment var global int func void main[] // Local variable // located and initialized at stack var local int end Using local/global storage type of variables has no differences for end-user programmer, as it differs at code generation level and only will affect memory layout","title":"Local and static (global) variable location: differences"},{"location":"tutorial/variables/#local-variables-alignment-on-cpus","text":"Each local variable must be alignment on most architectures (CPUs) so for example definition of three local variables like that: var a int var b int var c byte will result in 24 bytes total space allocated at callee, as: int: 8 bytes int: 8 bytes byte: 1 byte that sums to 17, but for example on AARCH64 stack must be aligned by 16 bytes so we must align that to next value: 32 bytes and space that is left after two first integers has 16 (15, excluding third variable) more space which is unusable","title":"Local variables: alignment on CPUs"}]}