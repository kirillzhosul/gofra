// ==============================================
// HTTP server implementation
// ==============================================

#include "os/network.gof"
#include "types.gof"

// TODO: Add async/thread support

// IO RX/TX buffer capacity expected
#define HTTP_IO_BUFFER_CAP 4096

struct HTTPServer
    // HTTP Server instance for HTTP library

    socket  int // System socket opened for listening
    port    int // Port on which server is listening
    backlog int // Backlog -  maximum length for the queue of pending connections

    // Internal fields
    net_addr sockaddr_in // Addr as `sockaddr_in` to listen on
end

struct HTTPIncomingRequest
    // Request for HTTP server from client

    socket int // System socket bound for that client

    io_rx_buffer *char[HTTP_IO_BUFFER_CAP] // Buffer for reading request
    io_tx_buffer *char[HTTP_IO_BUFFER_CAP] // Buffer for writing request
end

// Open system socket for server, internal function
func void _http_server_open_socket[*HTTPServer]
    var server *HTTPServer; &server swap !<

    &server.socket call net_ipv4_tcp_socket !<
    server.socket 0 < if 
        "Unable to open HTTP server socket\n" eprint_fatal
    end
end

// Bind system socket for server, internal function
func void _http_server_bind_socket[*HTTPServer]
    var server *HTTPServer; &server swap !<

    &server.socket ?>
    &server.net_addr // *sock_addr_in
    sizeof sockaddr_in
    call net_bind
    
    -1 == if
        "Unable to bind HTTP server socket\n" eprint_fatal
    end
end

// Listen system socket for server, internal function
func void _http_server_listen_socket[*HTTPServer]
    var server *HTTPServer; &server swap !<

        server.socket
        server.backlog
    call net_listen 

    -1 == if
        "Unable to listen to HTTP server socket\n" eprint_fatal
    end
end

// Internal wrapper around system network write bytes
func int _http_server_net_write_bytes[int, *string]
    var sv *string; &sv swap !<;

    sv.data sv.len call net_write
    copy -1 == if
        "Unable to send response to client socket on HTTP server socket\n" eprint_fatal
        // todo: close socket
    end
end

// Bootstrap HTTP server
func void http_server_start[*HTTPServer]
    var server *HTTPServer; &server swap !<

    server call _http_server_open_socket
    server call _http_server_bind_socket
    server call _http_server_listen_socket
end

// Send given string payload as HTML to client
func int http_server_send_html_response[*HTTPIncomingRequest, *string]
    var request *HTTPIncomingRequest; &request swap !<
    var sv *string; &sv swap !<;
    var bytes_written int = 0

    request.socket
    "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n"
    call _http_server_net_write_bytes
    &bytes_written swap bytes_written + !<

    request.socket sv
    call _http_server_net_write_bytes
    &bytes_written swap bytes_written + !<

    request.socket
    "\r\n"
    call _http_server_net_write_bytes
    &bytes_written swap bytes_written + !<

    // TODO: use io_tx_buffer
    bytes_written return
end

// Read an HTTP request with headers
func int http_server_read_request[*HTTPIncomingRequest]
    var request *HTTPIncomingRequest; request swap !<
    var bytes_read int = 0

        request.socket
        &request.io_rx_buffer 
        HTTP_IO_BUFFER_CAP
    net_read &bytes_read swap !<

    bytes_read -1 == if
        "Unable to read response from client socket on HTTP server socket\n" eprint_fatal
    end

    bytes_read return
end

// Close client request finishing request-response interaction
func void http_server_close_request[*HTTPIncomingRequest]
    var request *HTTPIncomingRequest; request swap !<

    request.socket call net_close -1 == if
        "Unable to close client socket on HTTP server socket\n" eprint_fatal
    end
end