// ==============================================
// HTTP server implementation
// ==============================================

#include "os/network.gof"

// IO RX/TX buffer capacity expected
#define HTTP_IO_BUFFER_CAP 4096

struct HTTPServer
    // HTTP Server instance for HTTP library

    socket  int // System socket opened for listening
    port    int // Port on which server is listening
    backlog int // Backlog -  maximum length for the queue of pending connections

    // Internal fields
    net_addr sockaddr_in // Addr as `sockaddr_in` to listen on
end

struct HTTPIncomingRequest
    // Request for HTTP server from client

    socket int // System socket bound for that client

    io_rx_buffer *char[HTTP_IO_BUFFER_CAP] // Buffer for reading request
    io_tx_buffer *char[HTTP_IO_BUFFER_CAP] // Buffer for writing request
end

// Open system socket for server, internal function
func void _http_server_open_socket[*HTTPServer]
    var server *HTTPServer; server swap !<

    server.socket call net_ipv4_tcp_socket !<
    server.socket ?> 0 < if 
        "Unable to open HTTP server socket\n" eprint_fatal
    end
end

// Bind system socket for server, internal function
func void _http_server_bind_socket[*HTTPServer]
    var server *HTTPServer; server swap !<

    server.socket ?>
    server.net_addr // *sock_addr_in
    sizeof sockaddr_in
    call net_bind
    
    -1 == if
        "Unable to bind HTTP server socket\n" eprint_fatal
    end
end

// Listen system socket for server, internal function
func void _http_server_listen_socket[*HTTPServer]
    var server *HTTPServer; server swap !<

        server.socket ?> 
        server.backlog ?> 
    call net_listen 

    -1 == if
        "Unable to listen to HTTP server socket\n" eprint_fatal
    end
end

// Internal wrapper around system network write bytes
func int _http_server_net_write_bytes[int, *char[], int]
    net_write
    copy -1 == if
        "Unable to send response to client socket on HTTP server socket\n" eprint_fatal
        // todo: close socket
    end
end

// Bootstrap HTTP server
func void http_server_start[*HTTPServer]
    var server *HTTPServer; server swap !<
    server ?> call _http_server_open_socket
    server ?> call _http_server_bind_socket
    server ?> call _http_server_listen_socket
end

// Send given string payload as HTML to client
func int http_server_send_html_response[*HTTPIncomingRequest, *char[]]
    var payload *char[]; payload swap !<
    var request *HTTPIncomingRequest; request swap !<
    var bytes_written int = 0

    request.socket ?>
    "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n"
    call _http_server_net_write_bytes
    bytes_written swap bytes_written ?> + !<

    request.socket ?>
    payload ?>
    call _http_server_net_write_bytes
    bytes_written swap bytes_written ?> + !<

    request.socket ?>
    "\r\n"
    call _http_server_net_write_bytes
    bytes_written swap bytes_written ?> + !<

    // TODO: use io_tx_buffer
    bytes_written ?>
end

// Read an HTTP request with headers
func int http_server_read_request[*HTTPIncomingRequest]
    var request *HTTPIncomingRequest; request swap !<
    var bytes_read int = 0

        request.socket ?> 
        request.io_rx_buffer 
        HTTP_IO_BUFFER_CAP
    net_read bytes_read swap !<

    bytes_read ?> -1 == if
        "Unable to read response from client socket on HTTP server socket\n" eprint_fatal
    end

    bytes_read ?>
end

// Close client request finishing request-response interaction
func void http_server_close_request[*HTTPIncomingRequest]
    var request *HTTPIncomingRequest; request swap !<

    request.socket ?> net_close -1 == if
        "Unable to close client socket on HTTP server socket\n" eprint_fatal
    end
end